<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

h1 {
    text-align: center;
    color: #667eea;
    margin-bottom: 30px;
    font-size: 2em;
}



.control-group:last-child {
    margin-bottom: 0;
}

label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
}

select, input[type="number"] {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s;
}

select:focus, input[type="number"]:focus {
    outline: none;
    border-color: #667eea;
}



.radio-group {
    display: flex;
    gap: 15px;
    margin-top: 8px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 5px;
}

.radio-option input[type="radio"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.checkboxes-container {
    margin-top: 15px;
    padding: 15px;
    background: white;
    border-radius: 8px;
    border: 2px solid #e0e0e0;
}

.checkboxes-grid {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.checkbox-item {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 8px 12px;
    border-radius: 6px;
    transition: all 0.1s;
}

.checkbox-item.active {
    background: #667eea;
    color: white;
    transform: scale(1.1);
}

.checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

@keyframes countPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.count-in-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    text-align: center;
    padding: 30px;
    background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%);
    border-radius: 15px;
    color: white;
    font-size: 72px;
    font-weight: bold;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 212, 59, 0.4);
    animation: countPulse 0.5s ease;
}

.count-in-display.hidden {
    display: none !important;
}

.song-cue {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    text-align: center;
    padding: 15px 40px;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    border-radius: 0 0 15px 15px;
    color: white;
    font-size: 24px;
    font-weight: bold;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.5);
    animation: cuePulse 0.8s ease infinite;
    max-width: 80%;
}
.song-cue.hidden {
    display: none !important;
}

.song-cue .countdown {
    font-size: 20px;
    margin-top: 5px;
}

@keyframes cuePulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.9; }
}



.progression-display {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.progression-display.hidden {
    display: none !important;
}

/*
.chord-box {
    flex: 1;
    max-width: 350px;
    text-align: center;
    min-width: 250px;
}

.chord-box .label {
    font-size: 14px;
    color: #666;
    margin-bottom: 10px;
    text-transform: uppercase;
    font-weight: 600;
}

.chord-box .chord-value {
    display: inline-block;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 48px;
    font-weight: bold;
}

.chord-box.current .chord-value {
    background: #dee2e6;
    color: #495057;
    font-size: 32px;
    padding: 15px 30px;
}

.chord-box.next .chord-value {
    background: #ffc107;
    color: #000;
}
*/

.chords-section h2 {
    color: #667eea;
    margin-bottom: 20px;
    text-align: center;
}




.chord-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}

.chord-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
}

.chord-btn.playing {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    animation: pulse 0.3s ease;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.controls-section {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 15px;
}

.control-group {
    margin-bottom: 10px;
}

.controls-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.controls-row-three {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.rhythm-controls {
    display: contents;
}

.rhythm-group {
    min-width: auto;
}

.checkboxes-row {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.checkboxes-row label {
    display: inline;
    margin-bottom: 0;
    font-weight: 500;
    font-size: 14px;
}

.progression-container {
    margin: 15px 0;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 10px;
}

.beat-grid-container {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-behavior: smooth;
}

.beat-grid-wrapper {
    display: inline-block;
    min-width: 100%;
}

.beat-grid {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-bottom: 10px;
}

.beat-box {
    aspect-ratio: 1;
    border: 3px solid #dee2e6;
    border-radius: 8px;
    background: white;
    position: relative;
    transition: all 0.2s ease;
}

.beat-box.bar-start {
    border-left: 5px solid #667eea;
}

.beat-box.active {
    background: #667eea;
    border-color: #667eea;
    transform: scale(1.1);
    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
}

.beat-box.played {
    background: #e9ecef;
    border-color: #adb5bd;
}

.beat-box .beat-number {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 10px;
    color: #6c757d;
    font-weight: 600;
}

.beat-box.active .beat-number {
    color: white;
}


.chord-labels {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-top: 5px;
}

.cue-labels {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-top: 5px;
}

.cue-label-box {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: white;
    background: #51cf66;
    padding: 8px 4px;
    border-radius: 6px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.cue-label-box.empty {
    background: transparent;
}

.cue-label-box.passed {
    background: #95d5a7;
    opacity: 0.5;
}

.chord-label {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: #000;
    background: #ffc107;
    padding: 8px 4px;
    border-radius: 6px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chord-label.empty {
    background: transparent;
}

.current-chord-small {
    text-align: center;
    padding: 10px;
    background: #e9ecef;
    border-radius: 8px;
    font-size: 16px;
}

.current-chord-small .label-small {
    color: #666;
    margin-right: 10px;
    font-weight: 600;
}

.current-chord-small #currentChordSmall {
    font-size: 24px;
    font-weight: bold;
    color: #495057;
}

.chords-section {
    margin-top: 15px;
}

.chord-buttons {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.chord-btn {
    padding: 30px;
    font-size: 24px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

.control-buttons {
    display: flex;
    gap: 15px;
    margin-top: 15px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

.start-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
}

.start-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
}

.start-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(81, 207, 102, 0.4);
}

.start-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.start-btn:disabled:hover {
    transform: none;
}

.stop-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
}

.stop-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
}

.stop-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
}

.stop-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.stop-btn:disabled:hover {
    transform: none;
}

.wrong-chord-flash {
    animation: wrongFlash 0.5s ease;
}

@keyframes wrongFlash {
    0%, 100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    50% { background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); }
}
@keyframes nextChordFlash {
    0%, 100% { 
        background: #ffc107;
        transform: scale(1);
    }
    50% { 
        background: #51cf66;
        transform: scale(1.1);
    }
}
//.chord-box.next 
.chord-value.flash {
    animation: nextChordFlash 0.4s ease;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Chord Player</h1>
        
        <div class="controls-section">
			<div class="controls-row">
				<div class="control-group">
					<label for="songSelect">Song:</label>
					<select id="songSelect">
						<option value="">-- Select a Song --</option>
						<option value="inthandam">Inthandam</option>
						<option value="ChinniChinni">Chinni Chinni Aasa</option>
					</select>
				</div>

				<div class="control-group">
					<label for="instrument">Instrument:</label>
					<select id="instrument">
						<option value="guitar">Guitar</option>
						<option value="violin">Violin</option>
						<option value="pads">Pads</option>
					</select>
				</div>
			</div>

			<div class="controls-row-three">
				<div class="control-group">
					<label for="bpm">BPM:</label>
					<input type="number" id="bpm" value="120" min="40" max="240">
				</div>

				<div class="control-group">
					<label for="timeSignature">Time Signature:</label>
					<select id="timeSignature">
						<option value="4/4">4/4</option>
						<option value="3/4">3/4</option>
					</select>
				</div>

				<div class="control-group">
					<label>Note Division:</label>
					<div class="radio-group">
						<div class="radio-option">
							<input type="radio" name="division" value="4" id="div4" checked>
							<label for="div4">4</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="8" id="div8">
							<label for="div8">8</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="16" id="div16">
							<label for="div16">16</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="32" id="div32">
							<label for="div32">32</label>
						</div>
					</div>
				</div>
			</div>

			<div class="checkboxes-row">
				<label>
					<input type="checkbox" id="immediateMode" checked>
					Immediate Response Mode
				</label>
				<label>
					<input type="checkbox" id="repeatMode">
					Repeat
				</label>
				<label>
					<input type="checkbox" id="sustainMode">
					Sustain
				</label>
			</div>

			<div class="checkboxes-container">
				<div class="checkboxes-grid" id="checkboxesGrid"></div>
			</div>
		</div>

        <div class="count-in-display hidden" id="countInDisplay"></div>

        <div class="song-cue hidden" id="songCue">
            <div id="cueText"></div>
            <div class="countdown" id="cueCountdown"></div>
        </div>

		<div class="progression-container">
			<div id="progressionDisplay" class="progression-display hidden">
				<div class="beat-grid-container" id="beatGridContainer">
					<div class="beat-grid-wrapper">
						<div class="beat-grid" id="beatGrid"></div>
						<div class="chord-labels" id="chordLabels"></div>
						<div class="cue-labels" id="cueLabels"></div>
					</div>
				</div>
				<div class="current-chord-small">
					<span class="label-small">Currently Playing:</span>
					<span id="currentChordSmall">--</span>
				</div>
			</div>
		</div>
        <div class="chords-section">
            <h2>Chords</h2>
            <div class="chord-buttons"></div>
            <div class="control-buttons">
                <button class="start-btn" id="startBtn">‚ñ∂ START COUNT-IN</button>
                <button class="stop-btn" id="stopBtn" disabled>‚èπ STOP</button>
            </div>
        </div>
    </div>

    <script>
        // Chord definitions (note names for each chord)
const chordDefinitions = {
    'E': ['E3', 'G#3', 'B3', 'E4'],
    'B': ['B3', 'D#4', 'F#4', 'B4'],
    'G#m': ['G#3', 'B3', 'D#4', 'G#4'],
    'C#m': ['C#3', 'E3', 'G#3', 'C#4'],
    'A': ['A3', 'C#4', 'E4', 'A4'],
    'F#m': ['F#3', 'A3', 'C#4', 'F#4'],
    'Eb': ['Eb3', 'G3', 'Bb3', 'Eb4'],
    'Ab': ['Ab3', 'C4', 'Eb4', 'Ab4'],
    'Db': ['Db3', 'F3', 'Ab3', 'Db4'],
    'Bb': ['Bb3', 'D4', 'F4', 'Bb4'],
    'Bbm': ['Bb3', 'Db4', 'F4', 'Bb4'],
    'Fm': ['F3', 'Ab3', 'C4', 'F4'],
    'Fm7': ['F3', 'Ab3', 'C4', 'Eb4']
};

// Song definitions - EASY TO ADD/EDIT SONGS HERE
const songs = {
    inthandam: {
        name: 'Inthandam',
        bpm: 200,
        timeSignature: '4/4',
		chords: ['E', 'B', 'G#m', 'C#m', 'A', 'F#m'], 
        progression: [
            // Intro pattern
			{ chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            
            // Cue for singing
            { cue: 'Start Singing', beat: 1 },
            
            // Verse pattern
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 },
			
            // Cue for chorus
            { cue: 'Sing Chorus', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			
			{ chord: 'B', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
			
			{ chord: 'C#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 }
			
        ]
    },
	ChinniChinni: {
        name: 'Chinni Chinni Aasa',
        bpm: 176,
        timeSignature: '4/4',
		chords: ['Eb', 'Bb', 'Db', 'Ab', 'Fm', 'Bbm', 'Fm', 'Fm7'], 
        progression: [
            // Intro pattern
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
			{ chord: 'Db', beat: 2 },
			{ chord: 'Db', beat: 1 },
			{ chord: 'Eb', beat: 1 },
			{ cue: 'Start Singing', beat: 2 },
			
        ]
    }
};

// State variables
let synth = null;
let sustainSynth = null;
let reverb = null;
let chorus = null;
let compressor = null;
let isPlaying = false;
let isCountingIn = false;
let waitingForFirstChord = false;
let currentChord = null;
let nextChord = null;
let metronomeInterval = null;
let currentBeatIndex = 0;
let barStartTime = null;
let nextBeatTime = null;
let isScheduling = false;
let beatsPlayedInBar = 0;
let chordStartBeatIndex = -1;
let sustainedChord = null;
let sustainInterval = null;
let currentSong = null;
let progressionIndex = 0;
let songMode = false;
let cueCountdown = 0;

// Initialize synth based on instrument
function initSynth(instrument) {
    if (synth) synth.dispose();
    if (sustainSynth) sustainSynth.dispose();
    if (reverb) reverb.dispose();
    if (chorus) chorus.dispose();
    if (compressor) compressor.dispose();

    // Create effects chain
    reverb = new Tone.Reverb({
        decay: 2.5,
        wet: 0.3
    }).toDestination();
    
    chorus = new Tone.Chorus({
        frequency: 1.5,
        delayTime: 3.5,
        depth: 0.7,
        wet: 0.3
    }).connect(reverb);
    
    compressor = new Tone.Compressor({
        threshold: -24,
        ratio: 4,
        attack: 0.003,
        release: 0.1
    }).connect(chorus);

    switch(instrument) {
        case 'guitar':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.3, 
                    sustain: 0.4, 
                    release: 1.5 
                },
                volume: -8
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.1, 
                    sustain: 0.8, 
                    release: 0.8 
                },
                volume: -8
            }).connect(compressor);
            break;
            
        case 'violin':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.2, 
                    sustain: 0.7, 
                    release: 0.6 
                },
                volume: -10
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.1, 
                    sustain: 0.9, 
                    release: 0.4 
                },
                volume: -10
            }).connect(compressor);
            break;
            
        case 'pads':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.4, 
                    decay: 0.3, 
                    sustain: 0.8, 
                    release: 2.5 
                },
                volume: -6
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.3, 
                    decay: 0.2, 
                    sustain: 0.9, 
                    release: 1.5 
                },
                volume: -6
            }).connect(compressor);
            break;
    }
}

// Initialize checkboxes
function updateCheckboxes() {
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const grid = document.getElementById('checkboxesGrid');
    grid.innerHTML = '';

    for (let i = 1; i <= division; i++) {
        const item = document.createElement('div');
        item.className = 'checkbox-item';
        item.innerHTML = `
            <input type="checkbox" id="beat${i}" checked>
            <label for="beat${i}">${i}</label>
        `;
        grid.appendChild(item);
    }
}

// Update visual metronome
function updateMetronome(beatIndex) {
    const items = document.querySelectorAll('.checkbox-item');
    items.forEach((item, i) => {
        if (i === beatIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

// Update current chord display
// Update current chord display
function updateChordDisplay(chordName) {
    document.getElementById('currentChordSmall').textContent = chordName || '--';
}

// Calculate total beats to display (entire song + 2 count-in bars)
function getTotalBeatsToDisplay() {
    if (!currentSong || !songMode) return 12; // Default 3 bars
    
    const beatsPerBar = getBeatsPerBar();
    let totalBars = 2; // Start with 2 count-in bars
    
    currentSong.progression.forEach(item => {
        if (typeof item === 'object' && (item.chord || item.cue)) {
            totalBars++;
        }
    });
    
    return totalBars * beatsPerBar;
}

// Get beats per bar
function getBeatsPerBar() {
    const timeSignature = document.getElementById('timeSignature').value;
    return parseInt(timeSignature.split('/')[0]);
}

function createBeatGrid() {
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    const beatGrid = document.getElementById('beatGrid');
    const chordLabels = document.getElementById('chordLabels');
    const cueLabels = document.getElementById('cueLabels');
    
    beatGrid.innerHTML = '';
    chordLabels.innerHTML = '';
    cueLabels.innerHTML = '';
    
    for (let i = 0; i < totalBeats; i++) {
        // Create beat box
        const beatBox = document.createElement('div');
        beatBox.className = 'beat-box';
        beatBox.id = `beat-box-${i}`;
        
        // Mark bar starts
        if (i % beatsPerBar === 0) {
            beatBox.classList.add('bar-start');
        }
        
        // Add beat number
        const beatNumber = document.createElement('div');
        beatNumber.className = 'beat-number';
        beatNumber.textContent = (i % beatsPerBar) + 1;
        beatBox.appendChild(beatNumber);
        
        beatGrid.appendChild(beatBox);
        
        // Create chord label placeholder
        const chordLabel = document.createElement('div');
        chordLabel.className = 'chord-label empty';
        chordLabel.id = `chord-label-${i}`;
        
        // Mark count-in bars (first 2 bars)
        if (i < beatsPerBar * 2) {
            chordLabel.textContent = 'COUNT';
            chordLabel.className = 'chord-label count-in-label';
            chordLabel.style.background = '#95d5a7';
            chordLabel.style.fontSize = '12px';
        }
        
        chordLabels.appendChild(chordLabel);
        
        // Create cue label placeholder
        const cueLabel = document.createElement('div');
        cueLabel.className = 'cue-label-box empty';
        cueLabel.id = `cue-label-${i}`;
        cueLabels.appendChild(cueLabel);
    }
}

function updateBeatGrid() {
    if (!currentSong || !songMode) return;
    
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    const countInBeats = beatsPerBar * 2; // 2 bars of count-in
    
    // Clear all labels (except count-in labels)
    for (let i = countInBeats; i < totalBeats; i++) {
        const chordLabel = document.getElementById(`chord-label-${i}`);
        const cueLabel = document.getElementById(`cue-label-${i}`);
        if (chordLabel) {
            chordLabel.textContent = '';
            chordLabel.className = 'chord-label empty';
        }
        if (cueLabel) {
            cueLabel.textContent = '';
            cueLabel.className = 'cue-label-box empty';
        }
    }
    
    // Place all items starting after count-in bars
    let currentBeatPosition = countInBeats;
    
    for (let i = 0; i < currentSong.progression.length; i++) {
        const item = currentSong.progression[i];
        
        // Handle cues
        if (typeof item === 'object' && item.cue) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const cueLabel = document.getElementById(`cue-label-${beatIndex}`);
                if (cueLabel) {
                    cueLabel.textContent = item.cue.charAt(0);
                    cueLabel.className = 'cue-label-box';
                    cueLabel.title = item.cue;
                }
            }
            
            currentBeatPosition += beatsPerBar;
            continue;
        }
        
        if (typeof item === 'object' && item.chord && item.beat) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const label = document.getElementById(`chord-label-${beatIndex}`);
                if (label) {
                    label.textContent = item.chord;
                    label.className = 'chord-label';
                }
            }
            
            currentBeatPosition += beatsPerBar;
        }
    }
}


function highlightBeatInGrid(beatNumber) {
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    
    // Calculate absolute beat position based on current beat index from metronome
    const absoluteBeatIndex = currentBeatIndex;
    
    // Clear all active states
    for (let i = 0; i < totalBeats; i++) {
        const box = document.getElementById(`beat-box-${i}`);
        if (box) {
            box.classList.remove('active');
        }
        
        // Mark cues as passed
        if (i < absoluteBeatIndex) {
            const cueLabel = document.getElementById(`cue-label-${i}`);
            if (cueLabel && !cueLabel.classList.contains('empty')) {
                cueLabel.classList.add('passed');
            }
        }
    }
    
    // Highlight current beat
    const currentBox = document.getElementById(`beat-box-${absoluteBeatIndex}`);
    if (currentBox) {
        currentBox.classList.add('active');
        
        // Auto-scroll: keep current beat in view, start scrolling after first bar
        const container = document.getElementById('beatGridContainer');
        const boxWidth = 68; // 60px width + 8px gap
        const containerWidth = container.clientWidth;
        const beatsVisible = Math.floor(containerWidth / boxWidth);
        
        // Start scrolling when we're past the first bar
        if (absoluteBeatIndex >= beatsPerBar) {
            const scrollPosition = (absoluteBeatIndex - beatsPerBar + 1) * boxWidth;
            container.scrollLeft = scrollPosition;
        }
    }
}


// Show count-in display
function showCountIn(count) {
    const display = document.getElementById('countInDisplay');
    display.textContent = count;
    display.classList.remove('hidden');
    display.style.animation = 'none';
    setTimeout(() => {
        display.style.animation = 'countPulse 0.5s ease';
    }, 10);
}

// Hide count-in display
function hideCountIn() {
    document.getElementById('countInDisplay').classList.add('hidden');
}

// Show song cue
function showSongCue(text, countdown) {
    const cueElement = document.getElementById('songCue');
    const cueText = document.getElementById('cueText');
    const cueCountdownEl = document.getElementById('cueCountdown');
    
    cueText.textContent = text;
    cueElement.classList.remove('hidden');
    
    if (countdown) {
        const timeSignature = document.getElementById('timeSignature').value;
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        cueCountdown = beatsPerBar;
        cueCountdownEl.textContent = cueCountdown;
    } else {
        cueCountdownEl.textContent = '';
    }
}

function hideSongCue() {
    document.getElementById('songCue').classList.add('hidden');
    cueCountdown = 0;
}

function updateCueCountdown() {
    if (cueCountdown > 0) {
        const cueCountdownEl = document.getElementById('cueCountdown');
        
        if (cueCountdown === 1) {
            cueCountdownEl.textContent = 'NOW!';
        } else {
            cueCountdownEl.textContent = cueCountdown - 1;
        }
        
        cueCountdown--;
        
        if (cueCountdown === 0) {
            setTimeout(() => hideSongCue(), 500);
        }
    }
}

// Display chord progression
// Display chord progression
function displayProgression() {
    if (!currentSong) return;
    
    const display = document.getElementById('progressionDisplay');
    
    if (progressionIndex >= currentSong.progression.length) {
        document.getElementById('currentChordSmall').textContent = 'Complete! üéâ';
        return;
    }
    
    createBeatGrid();
    updateBeatGrid();
    
    display.classList.remove('hidden');
}

// Load song
// Load song
function loadSong(songKey) {
    if (!songKey) {
        currentSong = null;
        songMode = false;
        progressionIndex = 0;
        document.getElementById('progressionDisplay').classList.add('hidden');
        // Reset to default chords
        displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']);
        return;
    }
    
    currentSong = songs[songKey];
    songMode = true;
    progressionIndex = 0;
    
    document.getElementById('bpm').value = currentSong.bpm;
    document.getElementById('timeSignature').value = currentSong.timeSignature;
    
    // Display chord buttons for this song
    displayChordButtons(currentSong.chords);
    
    displayProgression();
}

// Display chord buttons based on song
function displayChordButtons(chordList) {
    const buttonContainer = document.querySelector('.chord-buttons');
    buttonContainer.innerHTML = '';
    
    chordList.forEach(chordName => {
        const button = document.createElement('button');
        button.className = 'chord-btn';
        button.setAttribute('data-chord', chordName);
        button.textContent = chordName;
        
        // Add all event listeners
        button.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('mouseup', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('mouseleave', (e) => {
            stopSustain(chordName);
        });
        
        button.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        buttonContainer.appendChild(button);
    });
}

// Check and show cue
function checkAndShowCue() {
    if (!songMode || !currentSong) return;
    
    if (progressionIndex >= currentSong.progression.length) return;
    
    const item = currentSong.progression[progressionIndex];
    
    if (typeof item === 'object' && item.cue) {
        // Just advance past the cue, no overlay needed
        progressionIndex++;
        displayProgression();
    }
}

// Advance progression
// Advance progression
function advanceProgression() {
    if (!songMode || !currentSong) return;
    
    progressionIndex++;
    
    if (progressionIndex >= currentSong.progression.length) {
        displayProgression();
        return;
    }
    
    checkAndShowCue();
    updateBeatGrid(); // Update the grid with new upcoming chords
}

// Check song chord
function checkSongChord(chordName) {
    if (!songMode || !currentSong) return true;
    
    if (progressionIndex >= currentSong.progression.length) return false;
    
    const expectedItem = currentSong.progression[progressionIndex];
    
    if (typeof expectedItem === 'object' && expectedItem.cue) {
        return false;
    }
    
    // Handle new structure with beat information
    const expectedChord = typeof expectedItem === 'object' ? expectedItem.chord : expectedItem;
    
    if (chordName === expectedChord) {
        advanceProgression();
        return true;
    }
    
    advanceProgression();
    return false;
}


// Handle chord sustain (hold to play)
function startSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Stop any previous sustained chord
    if (sustainedChord) {
        const notes = chordDefinitions[sustainedChord];
        sustainSynth.triggerRelease(notes);
    }
    
    sustainedChord = chordName;
    const button = document.querySelector(`[data-chord="${chordName}"]`);
    button.classList.add('playing');
    
    // Play immediately with attack on the sustain synth
    const notes = chordDefinitions[chordName];
    sustainSynth.triggerAttack(notes, Tone.now());
}

function stopSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Only release if this is the currently sustained chord
    if (sustainedChord === chordName) {
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.remove('playing');
        
        // Release the notes on the sustain synth
        const notes = chordDefinitions[chordName];
        sustainSynth.triggerRelease(notes, Tone.now());
        
        sustainedChord = null;
    }
}

// Start count-in
function startCountIn() {
    isCountingIn = true;
    waitingForFirstChord = false;
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = (60 / bpm) * 1000;
    
    let countBeat = 1;
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    
    showCountIn(countBeat);
    countBeat++;
    
    const countInterval = setInterval(() => {
        if (countBeat <= beatsPerBar) {
            showCountIn(countBeat);
            countBeat++;
        } else {
            clearInterval(countInterval);
            hideCountIn();
            isCountingIn = false;
            waitingForFirstChord = true;
            
            startMetronomeWaiting();
            
            if (songMode) {
                checkAndShowCue();
            }
        }
    }, beatDuration);
}

// Start metronome in waiting mode
function startMetronomeWaiting() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now();
    
    isScheduling = true;
    scheduleMetronome();
}

// Start metronome and playback
function startMetronome() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now();
    
    isScheduling = true;
    scheduleMetronome();
}

// Precise scheduling function using Tone.js timing
function scheduleMetronome() {
    if (!isScheduling) return;
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    const quarterNoteDuration = 60 / bpm;
    const repeatMode = document.getElementById('repeatMode').checked;
    
    const now = Tone.now();
    const lookAhead = 0.1;
    
    while (nextBeatTime < now + lookAhead) {
        const beatIndex = currentBeatIndex;
        const beatTime = nextBeatTime;
        
        // Calculate which beat within the bar for the checkbox highlighting
        const beatInBar = currentBeatIndex % division;
        
        const visualOffset = 0.05;
        Tone.Draw.schedule(() => {
            updateMetronome(beatInBar);  // Use beatInBar for checkbox highlighting
            
            // Highlight beat in grid using absolute position
            highlightBeatInGrid(beatIndex);
            
            const currentQuarterBeat = Math.floor((beatIndex * noteDuration) / quarterNoteDuration);
            const prevQuarterBeat = beatIndex === 0 ? -1 : Math.floor(((beatIndex - 1) * noteDuration) / quarterNoteDuration);
            
            if (cueCountdown > 0 && currentQuarterBeat !== prevQuarterBeat) {
                updateCueCountdown();
            }
        }, beatTime - visualOffset);
        
        const checkboxes = document.querySelectorAll('.checkboxes-grid input[type="checkbox"]');
		const shouldPlay = currentChord && checkboxes[beatInBar] && checkboxes[beatInBar].checked;
		const immediateMode = document.getElementById('immediateMode').checked;

		// Only play from metronome if NOT in immediate mode
		if (shouldPlay && !immediateMode) {
			if (repeatMode || beatsPlayedInBar < division) {
				const notes = chordDefinitions[currentChord];
				const playDuration = noteDuration * 0.9;
				synth.triggerAttackRelease(notes, playDuration, beatTime);
			}
		}

		nextBeatTime += noteDuration;
		currentBeatIndex++;

		if (currentChord && !immediateMode) {
			beatsPlayedInBar++;
		}
        
        // Check if we've completed a bar
		// Check if we've completed a bar
		if (beatInBar === division - 1) {
			// In song mode with immediate response, don't auto-clear the chord
			const immediateMode = document.getElementById('immediateMode').checked;
			
			// Clear chord after one bar in immediate mode without repeat
			if (immediateMode && !repeatMode && currentChord) {
				const barsPlayed = Math.floor(beatsPlayedInBar / division);
				if (barsPlayed >= 1) {
					Tone.Draw.schedule(() => {
						currentChord = null;
						updateChordDisplay(null);
						beatsPlayedInBar = 0;
					}, beatTime);
				}
			}
			
			if (!repeatMode && !songMode && !immediateMode && beatsPlayedInBar >= division) {
				Tone.Draw.schedule(() => {
					currentChord = null;
					updateChordDisplay(null);
				}, beatTime);
			}
			
			// Only switch to nextChord if it was explicitly set (not in song mode with immediate)
			if (nextChord && !immediateMode) {
				currentChord = nextChord;
				nextChord = null;
				beatsPlayedInBar = 0;
				Tone.Draw.schedule(() => {
					updateChordDisplay(currentChord);
				}, beatTime);
			}
		}
    }
    
    requestAnimationFrame(scheduleMetronome);
}

// Find stopMetronome() and add these lines at the beginning:
function stopMetronome() {
    isScheduling = false;
    document.getElementById('beatGridContainer').scrollLeft = 0;
    chordStartBeatIndex = -1
   
    if (metronomeInterval) {
        clearInterval(metronomeInterval);
        metronomeInterval = null;
    }
    updateMetronome(-1);
    hideCountIn();
    hideSongCue();
    isPlaying = false;
    isCountingIn = false;
    waitingForFirstChord = false;
    currentChord = null;
    nextChord = null;
    updateChordDisplay(null);
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('startBtn').disabled = false;
    
    if (songMode && currentSong) {
        progressionIndex = 0;
        displayProgression();
    }
}

// Handle chord click
/*async function handleChordClick(chordName) {
    await Tone.start();
    
    const sustainMode = document.getElementById('sustainMode').checked;
    
    if (sustainMode) {
        startSustain(chordName);
        updateChordDisplay(chordName);
        return;
    }
    
    if (songMode) {
        const isCorrect = checkSongChord(chordName);
        
        if (!isCorrect && currentSong) {
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('wrong-chord-flash');
            setTimeout(() => button.classList.remove('wrong-chord-flash'), 500);
        }
    }
    
    const immediateMode = document.getElementById('immediateMode').checked;
    
		if (immediateMode && isPlaying) {
			// Update the chord and play it immediately
			currentChord = chordName;
			updateChordDisplay(chordName);
			
			// Track when this chord was clicked (absolute beat position)
			chordStartBeatIndex = currentBeatIndex;
			
			const bpm = parseInt(document.getElementById('bpm').value);
			const timeSignature = document.getElementById('timeSignature').value;
			const division = parseInt(document.querySelector('input[name="division"]:checked').value);
			const beatsPerBar = parseInt(timeSignature.split('/')[0]);
			const beatDuration = 60 / bpm;
			const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
			
			// Play immediately when clicked
			const notes = chordDefinitions[chordName];
			synth.triggerAttackRelease(notes, playDuration, Tone.now());
			
			const button = document.querySelector(`[data-chord="${chordName}"]`);
			button.classList.add('playing');
			setTimeout(() => button.classList.remove('playing'), 200);
			
			return;
		}
    
    if (waitingForFirstChord) {
        waitingForFirstChord = false;
        if (!immediateMode) {
            nextChord = chordName;
        } else {
            currentChord = chordName;
            updateChordDisplay(chordName);
        }
        beatsPlayedInBar = 0;
        isPlaying = true;
		} else if (!isPlaying && !isCountingIn) {
			currentChord = chordName;
			updateChordDisplay(chordName);
			beatsPlayedInBar = 0;
			chordStartBeatIndex = 0;
			isPlaying = true;
			startMetronome();  // Always start metronome
			document.getElementById('stopBtn').disabled = false;
			document.getElementById('startBtn').disabled = true;
			
			const sustainMode = document.getElementById('sustainMode').checked;
			
			// Play the first chord immediately if in immediate mode but NOT in sustain mode
			// (In sustain mode, sound only plays when button is held)
			if (immediateMode && !sustainMode) {
				const bpm = parseInt(document.getElementById('bpm').value);
				const timeSignature = document.getElementById('timeSignature').value;
				const division = parseInt(document.querySelector('input[name="division"]:checked').value);
				const beatsPerBar = parseInt(timeSignature.split('/')[0]);
				const beatDuration = 60 / bpm;
				const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
				
				const notes = chordDefinitions[chordName];
				synth.triggerAttackRelease(notes, playDuration, Tone.now());
				
				const button = document.querySelector(`[data-chord="${chordName}"]`);
				button.classList.add('playing');
				setTimeout(() => button.classList.remove('playing'), 200);
			}
		} else if (isPlaying && !immediateMode) {
        nextChord = chordName;
    }
}*/

async function handleChordClick(chordName) {
    await Tone.start();
    
    const sustainMode = document.getElementById('sustainMode').checked;
    const immediateMode = document.getElementById('immediateMode').checked;
    
    // In sustain mode, handle the sound separately
    if (sustainMode) {
        startSustain(chordName);
        updateChordDisplay(chordName);
        
        // If metronome isn't running yet, start it (for visual beat guidance)
        if (!isPlaying && !isCountingIn) {
            currentChord = chordName;
            beatsPlayedInBar = 0;
            chordStartBeatIndex = 0;
            isPlaying = true;
            startMetronome();
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('startBtn').disabled = true;
        }
        
        return; // Don't continue to the immediate/normal playback logic
    }
    
    if (songMode) {
        const isCorrect = checkSongChord(chordName);
        
        if (!isCorrect && currentSong) {
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('wrong-chord-flash');
            setTimeout(() => button.classList.remove('wrong-chord-flash'), 500);
        }
    }
    
    if (immediateMode && isPlaying) {
        // Update the chord and play it immediately
        currentChord = chordName;
        updateChordDisplay(chordName);
        
        // Track when this chord was clicked (absolute beat position)
        chordStartBeatIndex = currentBeatIndex;
        
        const bpm = parseInt(document.getElementById('bpm').value);
        const timeSignature = document.getElementById('timeSignature').value;
        const division = parseInt(document.querySelector('input[name="division"]:checked').value);
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        const beatDuration = 60 / bpm;
        const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
        
        // Play immediately when clicked
        const notes = chordDefinitions[chordName];
        synth.triggerAttackRelease(notes, playDuration, Tone.now());
        
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.add('playing');
        setTimeout(() => button.classList.remove('playing'), 200);
        
        return;
    }
    
    if (waitingForFirstChord) {
        waitingForFirstChord = false;
        if (!immediateMode) {
            nextChord = chordName;
        } else {
            currentChord = chordName;
            updateChordDisplay(chordName);
        }
        beatsPlayedInBar = 0;
        isPlaying = true;
    } else if (!isPlaying && !isCountingIn) {
        currentChord = chordName;
        updateChordDisplay(chordName);
        beatsPlayedInBar = 0;
        chordStartBeatIndex = 0;
        isPlaying = true;
        startMetronome();
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('startBtn').disabled = true;
        
        // Play the first chord immediately if in immediate mode
        if (immediateMode) {
            const bpm = parseInt(document.getElementById('bpm').value);
            const timeSignature = document.getElementById('timeSignature').value;
            const division = parseInt(document.querySelector('input[name="division"]:checked').value);
            const beatsPerBar = parseInt(timeSignature.split('/')[0]);
            const beatDuration = 60 / bpm;
            const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
            
            const notes = chordDefinitions[chordName];
            synth.triggerAttackRelease(notes, playDuration, Tone.now());
            
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('playing');
            setTimeout(() => button.classList.remove('playing'), 200);
        }
    } else if (isPlaying && !immediateMode) {
        nextChord = chordName;
    }
}

// Event listeners
document.getElementById('songSelect').addEventListener('change', (e) => {
    loadSong(e.target.value);
});

document.getElementById('instrument').addEventListener('change', (e) => {
    initSynth(e.target.value);
});

document.querySelectorAll('input[name="division"]').forEach(radio => {
    radio.addEventListener('change', () => {
        updateCheckboxes();
        if (isPlaying) {
            startMetronome();
        }
    });
});

document.getElementById('bpm').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.getElementById('timeSignature').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.querySelectorAll('.chord-btn').forEach(btn => {
    btn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseleave', (e) => {
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
});

document.getElementById('startBtn').addEventListener('click', async () => {
    await Tone.start();
    startCountIn();
});

document.getElementById('stopBtn').addEventListener('click', stopMetronome);


// Initialize
initSynth('guitar');
updateCheckboxes();
displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']);
createBeatGrid(); // Add this line
    </script>
</body>
</html>
