<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
	<!-- ADD THIS LINE: -->
	<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

h1 {
    text-align: center;
    color: #667eea;
    margin-bottom: 30px;
    font-size: 2em;
}



.control-group:last-child {
    margin-bottom: 0;
}

label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
}

select, input[type="number"] {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s;
}

select:focus, input[type="number"]:focus {
    outline: none;
    border-color: #667eea;
}



.radio-group {
    display: flex;
    gap: 15px;
    margin-top: 8px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 5px;
}

.radio-option input[type="radio"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.checkboxes-container {
    margin-top: 15px;
    padding: 15px;
    background: white;
    border-radius: 8px;
    border: 2px solid #e0e0e0;
}

.checkboxes-grid {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.checkbox-item {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 8px 12px;
    border-radius: 6px;
    transition: all 0.1s;
}

.checkbox-item.active {
    background: #667eea;
    color: white;
    transform: scale(1.1);
}

.checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

@keyframes countPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.count-in-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    text-align: center;
    padding: 30px;
    background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%);
    border-radius: 15px;
    color: white;
    font-size: 72px;
    font-weight: bold;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 212, 59, 0.4);
    animation: countPulse 0.5s ease;
}

.count-in-display.hidden {
    display: none !important;
}

.song-cue {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    text-align: center;
    padding: 15px 40px;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    border-radius: 0 0 15px 15px;
    color: white;
    font-size: 24px;
    font-weight: bold;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.5);
    animation: cuePulse 0.8s ease infinite;
    max-width: 80%;
}
.song-cue.hidden {
    display: none !important;
}

.song-cue .countdown {
    font-size: 20px;
    margin-top: 5px;
}

@keyframes cuePulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.9; }
}



.progression-display {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.progression-display.hidden {
    display: none !important;
}

/*
.chord-box {
    flex: 1;
    max-width: 350px;
    text-align: center;
    min-width: 250px;
}

.chord-box .label {
    font-size: 14px;
    color: #666;
    margin-bottom: 10px;
    text-transform: uppercase;
    font-weight: 600;
}

.chord-box .chord-value {
    display: inline-block;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 48px;
    font-weight: bold;
}

.chord-box.current .chord-value {
    background: #dee2e6;
    color: #495057;
    font-size: 32px;
    padding: 15px 30px;
}

.chord-box.next .chord-value {
    background: #ffc107;
    color: #000;
}
*/

.chords-section h2 {
    color: #667eea;
    margin-bottom: 20px;
    text-align: center;
}




.chord-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}

.chord-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
}

.chord-btn.playing {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    animation: pulse 0.3s ease;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.controls-section {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 15px;
}

.control-group {
    margin-bottom: 10px;
}

.controls-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.controls-row-three {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.rhythm-controls {
    display: contents;
}

.rhythm-group {
    min-width: auto;
}

.checkboxes-row {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.checkboxes-row label {
    display: inline;
    margin-bottom: 0;
    font-weight: 500;
    font-size: 14px;
}

.progression-container {
    margin: 15px 0;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 10px;
}

.beat-grid-container {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-behavior: smooth;
}

.beat-grid-wrapper {
    display: inline-block;
    min-width: 100%;
}

.beat-grid {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-bottom: 10px;
}

.beat-box {
    aspect-ratio: 1;
    border: 3px solid #dee2e6;
    border-radius: 8px;
    background: white;
    position: relative;
    transition: all 0.2s ease;
}

.beat-box.bar-start {
    border-left: 5px solid #667eea;
}

.beat-box.active {
    background: #667eea;
    border-color: #667eea;
    transform: scale(1.1);
    box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
}

.beat-box.played {
    background: #e9ecef;
    border-color: #adb5bd;
}

.beat-box .beat-number {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 10px;
    color: #6c757d;
    font-weight: 600;
}

.beat-box.active .beat-number {
    color: white;
}


.chord-labels {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-top: 5px;
}

.cue-labels {
    display: inline-grid;
    grid-auto-flow: column;
    grid-auto-columns: 60px;
    gap: 8px;
    margin-top: 5px;
}

.cue-label-box {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: white;
    background: #51cf66;
    padding: 8px 4px;
    border-radius: 6px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.cue-label-box.empty {
    background: transparent;
}

.cue-label-box.passed {
    background: #95d5a7;
    opacity: 0.5;
}

.chord-label {
    text-align: center;
    font-size: 18px;
    font-weight: bold;
    color: #000;
    background: #ffc107;
    padding: 8px 4px;
    border-radius: 6px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chord-label.empty {
    background: transparent;
}

.current-chord-small {
    text-align: center;
    padding: 10px;
    background: #e9ecef;
    border-radius: 8px;
    font-size: 16px;
}

.current-chord-small .label-small {
    color: #666;
    margin-right: 10px;
    font-weight: 600;
}

.current-chord-small #currentChordSmall {
    font-size: 24px;
    font-weight: bold;
    color: #495057;
}

.chords-section {
    margin-top: 15px;
}

.chord-buttons {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.chord-btn {
    padding: 30px;
    font-size: 24px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

.control-buttons {
    display: flex;
    gap: 15px;
    margin-top: 15px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

.start-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
}

.start-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
}

.start-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(81, 207, 102, 0.4);
}

.start-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.start-btn:disabled:hover {
    transform: none;
}

.stop-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
}

.stop-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
}

.stop-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
}

.stop-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.stop-btn:disabled:hover {
    transform: none;
}

.wrong-chord-flash {
    animation: wrongFlash 0.5s ease;
}

@keyframes wrongFlash {
    0%, 100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    50% { background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); }
}
@keyframes nextChordFlash {
    0%, 100% { 
        background: #ffc107;
        transform: scale(1);
    }
    50% { 
        background: #51cf66;
        transform: scale(1.1);
    }
}
//.chord-box.next 
.chord-value.flash {
    animation: nextChordFlash 0.4s ease;
}
/* Chord Selection Section */
.chord-selection-section {
    background: #f0f7ff;
    padding: 25px;
    border-radius: 15px;
    margin-bottom: 20px;
    border: 3px solid #667eea;
}

.chord-selection-section h3 {
    color: #667eea;
    margin-bottom: 10px;
    font-size: 1.5em;
    text-align: center;
}

.instruction-text {
    text-align: center;
    color: #666;
    margin-bottom: 20px;
    font-size: 16px;
}

.chord-selection-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.chord-select-item {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 15px;
    border: 3px solid #ddd;
    border-radius: 10px;
    background: white;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 18px;
    font-weight: bold;
}

.chord-select-item:hover {
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.chord-select-item input[type="checkbox"] {
    margin-right: 10px;
    width: 24px;
    height: 24px;
    cursor: pointer;
}

.chord-select-item.selected {
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    border-color: #2f9e44;
    color: white;
}

.ready-btn {
    width: 100%;
    padding: 18px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 12px;
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
}

.ready-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
}

.ready-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

/* Enhanced chord labels for personalized view */
.chord-label.my-chord {
    background: #51cf66;
    color: white;
    font-size: 20px;
    font-weight: bold;
    transform: scale(1.1);
    box-shadow: 0 2px 8px rgba(81, 207, 102, 0.4);
}

.chord-label.other-chord {
    background: #ffc107;
    opacity: 0.6;
    font-size: 14px;
}

/* Pulse animation for upcoming chords */
@keyframes chordPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.15); }
}

.chord-label.my-chord.upcoming {
    animation: chordPulse 0.8s ease-in-out infinite;
}

/* Room Section Styles */
.room-section {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 25px;
    border-radius: 15px;
    margin-bottom: 20px;
    color: white;
}

.room-section h3 {
    color: white;
    margin-bottom: 20px;
    font-size: 1.5em;
    text-align: center;
}

.room-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 20px;
}

.room-btn {
    padding: 18px;
    font-size: 18px;
    font-weight: bold;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.create-room-btn {
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    color: white;
}

.join-room-btn {
    background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%);
    color: #333;
}

.leave-room-btn {
    background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
    color: white;
    width: 100%;
    margin-top: 15px;
}

.room-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.room-btn:active {
    transform: translateY(0);
}

.room-info {
    background: rgba(255, 255, 255, 0.1);
    padding: 20px;
    border-radius: 12px;
    backdrop-filter: blur(10px);
}

.pin-display {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 10px;
}

.pin-display label {
    font-weight: bold;
    font-size: 16px;
    color: white;
}

.pin-code {
    font-size: 32px;
    font-weight: bold;
    letter-spacing: 8px;
    color: #ffd43b;
    flex: 1;
    text-align: center;
    font-family: 'Courier New', monospace;
}

.copy-btn {
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.2);
    border: 2px solid white;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
}

.copy-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.user-list-container {
    margin: 15px 0;
}

.user-list-container h4 {
    color: white;
    margin-bottom: 10px;
    font-size: 16px;
}

.user-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.user-item {
    background: rgba(255, 255, 255, 0.15);
    padding: 12px 15px;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.user-item.host {
    background: rgba(255, 212, 59, 0.3);
    border: 2px solid #ffd43b;
}

.user-info {
    display: flex;
    flex-direction: column;
    gap: 3px;
}

.user-name {
    font-weight: bold;
    font-size: 16px;
}

.user-details {
    font-size: 13px;
    opacity: 0.9;
}

.user-chords {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
}

.user-chord-tag {
    background: rgba(81, 207, 102, 0.8);
    padding: 3px 8px;
    border-radius: 5px;
    font-size: 12px;
    font-weight: bold;
}

/* Modal Styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: white;
    padding: 30px;
    border-radius: 15px;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
}

.modal-content h3 {
    color: #667eea;
    margin-bottom: 15px;
    text-align: center;
}

.modal-content p {
    color: #666;
    margin-bottom: 20px;
    text-align: center;
}

.pin-input {
    width: 100%;
    padding: 15px;
    font-size: 24px;
    text-align: center;
    letter-spacing: 8px;
    border: 3px solid #667eea;
    border-radius: 10px;
    font-family: 'Courier New', monospace;
    margin-bottom: 20px;
}

.pin-input:focus {
    outline: none;
    border-color: #764ba2;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
}

.modal-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

.modal-btn {
    padding: 15px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
}

.cancel-btn {
    background: #e9ecef;
    color: #333;
}

.confirm-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.modal-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.hidden {
    display: none !important;
}

    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Chord Player</h1>
        
        <div class="controls-section">
			<div class="controls-row">
				<div class="control-group">
					<label for="songSelect">Song:</label>
					<select id="songSelect">
						<option value="">-- Select a Song --</option>
						<option value="inthandam">Inthandam</option>
						<option value="ChinniChinni">Chinni Chinni Aasa</option>
					</select>
				</div>

				<div class="control-group">
					<label for="instrument">Instrument:</label>
					<select id="instrument">
						<option value="guitar">Guitar</option>
						<option value="violin">Violin</option>
						<option value="pads">Pads</option>
					</select>
				</div>
			</div>

			<div class="controls-row-three">
				<div class="control-group">
					<label for="bpm">BPM:</label>
					<input type="number" id="bpm" value="120" min="40" max="240">
				</div>

				<div class="control-group">
					<label for="timeSignature">Time Signature:</label>
					<select id="timeSignature">
						<option value="4/4">4/4</option>
						<option value="3/4">3/4</option>
					</select>
				</div>

				<div class="control-group">
					<label>Note Division:</label>
					<div class="radio-group">
						<div class="radio-option">
							<input type="radio" name="division" value="4" id="div4" checked>
							<label for="div4">4</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="8" id="div8">
							<label for="div8">8</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="16" id="div16">
							<label for="div16">16</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="32" id="div32">
							<label for="div32">32</label>
						</div>
					</div>
				</div>
			</div>

			<div class="checkboxes-row">
				<label>
					<input type="checkbox" id="immediateMode" checked>
					Immediate Response Mode
				</label>
				<label>
					<input type="checkbox" id="repeatMode">
					Repeat
				</label>
				<label>
					<input type="checkbox" id="sustainMode">
					Sustain
				</label>
			</div>

			<div class="checkboxes-container">
				<div class="checkboxes-grid" id="checkboxesGrid"></div>
			</div>
		</div>
		<!-- Multi-User Room Section -->
		<div class="room-section" id="roomSection">
			<h3>üéµ Multi-User Room</h3>
			
			<div class="room-controls" id="roomControls">
				<button class="room-btn create-room-btn" id="createRoomBtn">
					üè† Create Room (Host)
				</button>
				<button class="room-btn join-room-btn" id="joinRoomBtn">
					üö™ Join Room (Guest)
				</button>
			</div>
			
			<div class="room-info hidden" id="roomInfo">
				<div class="pin-display">
					<label>Room PIN:</label>
					<div class="pin-code" id="pinCode">------</div>
					<button class="copy-btn" id="copyPinBtn">üìã Copy</button>
				</div>
				
				<div class="user-list-container">
					<h4>Connected Users (<span id="userCount">0</span>)</h4>
					<div class="user-list" id="userList">
						<!-- Users will be added here dynamically -->
					</div>
				</div>
				
				<button class="room-btn leave-room-btn" id="leaveRoomBtn">
					üëã Leave Room
				</button>
			</div>
		</div>

		<!-- Join Room Modal -->
		<div class="modal hidden" id="joinRoomModal">
			<div class="modal-content">
				<h3>Join Room</h3>
				<p>Enter the 6-digit PIN:</p>
				<input type="text" id="joinPinInput" maxlength="6" placeholder="123456" class="pin-input">
				<div class="modal-buttons">
					<button class="modal-btn cancel-btn" id="cancelJoinBtn">Cancel</button>
					<button class="modal-btn confirm-btn" id="confirmJoinBtn">Join</button>
				</div>
			</div>
		</div>
		<!-- Add this NEW section after controls-section closes -->
		<div class="chord-selection-section" id="chordSelectionSection" style="display: none;">
			<h3>Select Your Chords</h3>
			<p class="instruction-text">Choose 1-4 chords you want to play:</p>
			<div class="chord-selection-grid" id="chordSelectionGrid">
				<!-- Will be populated dynamically -->
			</div>
			<button class="ready-btn" id="readyBtn" disabled>‚úì Ready to Play</button>
		</div>

        <div class="count-in-display hidden" id="countInDisplay"></div>

        <div class="song-cue hidden" id="songCue">
            <div id="cueText"></div>
            <div class="countdown" id="cueCountdown"></div>
        </div>

		<div class="progression-container">
			<div id="progressionDisplay" class="progression-display hidden">
				<div class="beat-grid-container" id="beatGridContainer">
					<div class="beat-grid-wrapper">
						<div class="beat-grid" id="beatGrid"></div>
						<div class="chord-labels" id="chordLabels"></div>
						<div class="cue-labels" id="cueLabels"></div>
					</div>
				</div>
				<div class="current-chord-small">
					<span class="label-small">Currently Playing:</span>
					<span id="currentChordSmall">--</span>
				</div>
			</div>
		</div>
        <div class="chords-section">
            <h2>Chords</h2>
            <div class="chord-buttons"></div>
            <div class="control-buttons">
                <button class="start-btn" id="startBtn">‚ñ∂ START COUNT-IN</button>
                <button class="stop-btn" id="stopBtn" disabled>‚èπ STOP</button>
            </div>
        </div>
    </div>

    <script>
        // Chord definitions (note names for each chord)
const chordDefinitions = {
    'E': ['E3', 'G#3', 'B3', 'E4'],
    'B': ['B3', 'D#4', 'F#4', 'B4'],
    'G#m': ['G#3', 'B3', 'D#4', 'G#4'],
    'C#m': ['C#3', 'E3', 'G#3', 'C#4'],
    'A': ['A3', 'C#4', 'E4', 'A4'],
    'F#m': ['F#3', 'A3', 'C#4', 'F#4'],
    'Eb': ['Eb3', 'G3', 'Bb3', 'Eb4'],
    'Ab': ['Ab3', 'C4', 'Eb4', 'Ab4'],
    'Db': ['Db3', 'F3', 'Ab3', 'Db4'],
    'Bb': ['Bb3', 'D4', 'F4', 'Bb4'],
    'Bbm': ['Bb3', 'Db4', 'F4', 'Bb4'],
    'Fm': ['F3', 'Ab3', 'C4', 'F4'],
    'Fm7': ['F3', 'Ab3', 'C4', 'Eb4']
};

// Song definitions - EASY TO ADD/EDIT SONGS HERE
const songs = {
    inthandam: {
        name: 'Inthandam',
        bpm: 200,
        timeSignature: '4/4',
		chords: ['E', 'B', 'G#m', 'C#m', 'A', 'F#m'], 
        progression: [
            // Intro pattern
			{ chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            
            // Cue for singing
            { cue: 'Start Singing', beat: 1 },
            
            // Verse pattern
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
            { chord: 'C#m', beat: 1 },
			{ chord: 'A', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 },
			
            // Cue for chorus
            { cue: 'Sing Chorus', beat: 1 },
            { chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'C#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			
			{ chord: 'B', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'E', beat: 1 },
			{ chord: 'B', beat: 1 },
			
			{ chord: 'C#m', beat: 1 },
			{ chord: 'G#m', beat: 1 },
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			
			{ chord: 'A', beat: 1 },
			{ chord: 'F#m', beat: 1 },
			{ chord: 'B', beat: 1 },
			{ chord: 'B', beat: 1 }
			
        ]
    },
	ChinniChinni: {
        name: 'Chinni Chinni Aasa',
        bpm: 176,
        timeSignature: '4/4',
		chords: ['Eb', 'Bb', 'Db', 'Ab', 'Fm', 'Bbm', 'Fm', 'Fm7'], 
        progression: [
            // Intro pattern
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Ab', beat: 1 },
            { chord: 'Eb', beat: 1 },
            { chord: 'Eb', beat: 1 },
			{ chord: 'Db', beat: 2 },
			{ chord: 'Db', beat: 1 },
			{ chord: 'Eb', beat: 1 },
			{ cue: 'Start Singing', beat: 2 },
			
        ]
    }
};

// State variables
let synth = null;
let sustainSynth = null;
let reverb = null;
let chorus = null;
let compressor = null;
let isPlaying = false;
let isCountingIn = false;
let waitingForFirstChord = false;
let currentChord = null;
let nextChord = null;
let metronomeInterval = null;
let currentBeatIndex = 0;
let barStartTime = null;
let nextBeatTime = null;
let isScheduling = false;
let beatsPlayedInBar = 0;
let chordStartBeatIndex = -1;
let sustainedChord = null;
let sustainInterval = null;
let currentSong = null;
let progressionIndex = 0;
let songMode = false;
let cueCountdown = 0;
// Multi-user assignment state
let selectedChords = [];
let isChordSelectionMode = false;
// Backend connection config
const BACKEND_URL = 'https://music-chord-backend.onrender.com';
let socket = null;
let myUserId = null;
let currentRoomId = null;
let currentRoomPin = null;
let myRole = null; // 'host' or 'guest'
let connectedUsers = [];

// Initialize synth based on instrument
function initSynth(instrument) {
    if (synth) synth.dispose();
    if (sustainSynth) sustainSynth.dispose();
    if (reverb) reverb.dispose();
    if (chorus) chorus.dispose();
    if (compressor) compressor.dispose();

    // Create effects chain
    reverb = new Tone.Reverb({
        decay: 2.5,
        wet: 0.3
    }).toDestination();
    
    chorus = new Tone.Chorus({
        frequency: 1.5,
        delayTime: 3.5,
        depth: 0.7,
        wet: 0.3
    }).connect(reverb);
    
    compressor = new Tone.Compressor({
        threshold: -24,
        ratio: 4,
        attack: 0.003,
        release: 0.1
    }).connect(chorus);

    switch(instrument) {
        case 'guitar':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.3, 
                    sustain: 0.4, 
                    release: 1.5 
                },
                volume: -8
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.1, 
                    sustain: 0.8, 
                    release: 0.8 
                },
                volume: -8
            }).connect(compressor);
            break;
            
        case 'violin':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.2, 
                    sustain: 0.7, 
                    release: 0.6 
                },
                volume: -10
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.1, 
                    sustain: 0.9, 
                    release: 0.4 
                },
                volume: -10
            }).connect(compressor);
            break;
            
        case 'pads':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.4, 
                    decay: 0.3, 
                    sustain: 0.8, 
                    release: 2.5 
                },
                volume: -6
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.3, 
                    decay: 0.2, 
                    sustain: 0.9, 
                    release: 1.5 
                },
                volume: -6
            }).connect(compressor);
            break;
    }
}

// Initialize checkboxes
function updateCheckboxes() {
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const grid = document.getElementById('checkboxesGrid');
    grid.innerHTML = '';

    for (let i = 1; i <= division; i++) {
        const item = document.createElement('div');
        item.className = 'checkbox-item';
        item.innerHTML = `
            <input type="checkbox" id="beat${i}" checked>
            <label for="beat${i}">${i}</label>
        `;
        grid.appendChild(item);
    }
}

// Update visual metronome
function updateMetronome(beatIndex) {
    const items = document.querySelectorAll('.checkbox-item');
    items.forEach((item, i) => {
        if (i === beatIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

// Update current chord display
// Update current chord display
function updateChordDisplay(chordName) {
    document.getElementById('currentChordSmall').textContent = chordName || '--';
}

// Calculate total beats to display (entire song + 2 count-in bars)
function getTotalBeatsToDisplay() {
    if (!currentSong || !songMode) return 12; // Default 3 bars
    
    const beatsPerBar = getBeatsPerBar();
    let totalBars = 2; // Start with 2 count-in bars
    
    currentSong.progression.forEach(item => {
        if (typeof item === 'object' && (item.chord || item.cue)) {
            totalBars++;
        }
    });
    
    return totalBars * beatsPerBar;
}

// Get beats per bar
function getBeatsPerBar() {
    const timeSignature = document.getElementById('timeSignature').value;
    return parseInt(timeSignature.split('/')[0]);
}

function createBeatGrid() {
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    const beatGrid = document.getElementById('beatGrid');
    const chordLabels = document.getElementById('chordLabels');
    const cueLabels = document.getElementById('cueLabels');
    
    beatGrid.innerHTML = '';
    chordLabels.innerHTML = '';
    cueLabels.innerHTML = '';
    
    for (let i = 0; i < totalBeats; i++) {
        // Create beat box
        const beatBox = document.createElement('div');
        beatBox.className = 'beat-box';
        beatBox.id = `beat-box-${i}`;
        
        // Mark bar starts
        if (i % beatsPerBar === 0) {
            beatBox.classList.add('bar-start');
        }
        
        // Add beat number
        const beatNumber = document.createElement('div');
        beatNumber.className = 'beat-number';
        beatNumber.textContent = (i % beatsPerBar) + 1;
        beatBox.appendChild(beatNumber);
        
        beatGrid.appendChild(beatBox);
        
        // Create chord label placeholder
        const chordLabel = document.createElement('div');
        chordLabel.className = 'chord-label empty';
        chordLabel.id = `chord-label-${i}`;
        
        // Mark count-in bars (first 2 bars)
        if (i < beatsPerBar * 2) {
            chordLabel.textContent = 'COUNT';
            chordLabel.className = 'chord-label count-in-label';
            chordLabel.style.background = '#95d5a7';
            chordLabel.style.fontSize = '12px';
        }
        
        chordLabels.appendChild(chordLabel);
        
        // Create cue label placeholder
        const cueLabel = document.createElement('div');
        cueLabel.className = 'cue-label-box empty';
        cueLabel.id = `cue-label-${i}`;
        cueLabels.appendChild(cueLabel);
    }
}

function updateBeatGrid() {
    if (!currentSong || !songMode) return;
    
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    const countInBeats = beatsPerBar * 2; // 2 bars of count-in
    
    // Clear all labels (except count-in labels)
    for (let i = countInBeats; i < totalBeats; i++) {
        const chordLabel = document.getElementById(`chord-label-${i}`);
        const cueLabel = document.getElementById(`cue-label-${i}`);
        if (chordLabel) {
            chordLabel.textContent = '';
            chordLabel.className = 'chord-label empty';
        }
        if (cueLabel) {
            cueLabel.textContent = '';
            cueLabel.className = 'cue-label-box empty';
        }
    }
    
    // Place all items starting after count-in bars
    let currentBeatPosition = countInBeats;
    
    for (let i = 0; i < currentSong.progression.length; i++) {
        const item = currentSong.progression[i];
        
        // Handle cues
        if (typeof item === 'object' && item.cue) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const cueLabel = document.getElementById(`cue-label-${beatIndex}`);
                if (cueLabel) {
                    cueLabel.textContent = item.cue.charAt(0);
                    cueLabel.className = 'cue-label-box';
                    cueLabel.title = item.cue;
                }
            }
            
            currentBeatPosition += beatsPerBar;
            continue;
        }
        
        if (typeof item === 'object' && item.chord && item.beat) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const label = document.getElementById(`chord-label-${beatIndex}`);
                if (label) {
                    label.textContent = item.chord;
                    label.className = 'chord-label';
                }
            }
            
            currentBeatPosition += beatsPerBar;
        }
    }
}

// Update beat grid with personalized highlighting
function updateBeatGridPersonalized() {
    if (!currentSong || !songMode) return;
    
    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    const countInBeats = beatsPerBar * 2;
    
    // Clear all labels (except count-in labels)
    for (let i = countInBeats; i < totalBeats; i++) {
        const chordLabel = document.getElementById(`chord-label-${i}`);
        const cueLabel = document.getElementById(`cue-label-${i}`);
        if (chordLabel) {
            chordLabel.textContent = '';
            chordLabel.className = 'chord-label empty';
        }
        if (cueLabel) {
            cueLabel.textContent = '';
            cueLabel.className = 'cue-label-box empty';
        }
    }
    
    // Place all items starting after count-in bars
    let currentBeatPosition = countInBeats;
    
    for (let i = 0; i < currentSong.progression.length; i++) {
        const item = currentSong.progression[i];
        
        // Handle cues
        if (typeof item === 'object' && item.cue) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const cueLabel = document.getElementById(`cue-label-${beatIndex}`);
                if (cueLabel) {
                    cueLabel.textContent = item.cue.charAt(0);
                    cueLabel.className = 'cue-label-box';
                    cueLabel.title = item.cue;
                }
            }
            
            currentBeatPosition += beatsPerBar;
            continue;
        }
        
        if (typeof item === 'object' && item.chord && item.beat) {
            const beatIndex = currentBeatPosition + (item.beat - 1);
            
            if (beatIndex < totalBeats) {
                const label = document.getElementById(`chord-label-${beatIndex}`);
                if (label) {
                    label.textContent = item.chord;
                    
                    // Check if this chord is in user's selected chords
                    const isMyChord = selectedChords.includes(item.chord);
                    
                    if (isMyChord) {
                        label.className = 'chord-label my-chord';
                    } else {
                        label.className = 'chord-label other-chord';
                    }
                }
            }
            
            currentBeatPosition += beatsPerBar;
        }
    }
}


function highlightBeatInGrid(beatNumber) {
    console.log('highlightBeatInGrid called with beatNumber:', beatNumber, 'currentBeatIndex:', currentBeatIndex); // ADD THIS

    const totalBeats = getTotalBeatsToDisplay();
    const beatsPerBar = getBeatsPerBar();
    
    // Calculate absolute beat position based on current beat index from metronome
    const absoluteBeatIndex = currentBeatIndex;
    console.log('absoluteBeatIndex:', absoluteBeatIndex, 'totalBeats:', totalBeats); // ADD THIS
    
    // Clear all active states
    for (let i = 0; i < totalBeats; i++) {
        const box = document.getElementById(`beat-box-${i}`);
        if (box) {
            box.classList.remove('active');
        }
        
        // Mark cues as passed
        if (i < absoluteBeatIndex) {
            const cueLabel = document.getElementById(`cue-label-${i}`);
            if (cueLabel && !cueLabel.classList.contains('empty')) {
                cueLabel.classList.add('passed');
            }
        }
    }
    
    // Highlight current beat
    const currentBox = document.getElementById(`beat-box-${absoluteBeatIndex}`);
    if (currentBox) {
        currentBox.classList.add('active');
        
        // Auto-scroll: keep current beat in view, start scrolling after first bar
        const container = document.getElementById('beatGridContainer');
        const boxWidth = 68; // 60px width + 8px gap
        const containerWidth = container.clientWidth;
        const beatsVisible = Math.floor(containerWidth / boxWidth);
        
        // Start scrolling when we're past the first bar
        if (absoluteBeatIndex >= beatsPerBar) {
            const scrollPosition = (absoluteBeatIndex - beatsPerBar + 1) * boxWidth;
            container.scrollLeft = scrollPosition;
        }
    }
}


// Show count-in display
function showCountIn(count) {
    const display = document.getElementById('countInDisplay');
    display.textContent = count;
    display.classList.remove('hidden');
    display.style.animation = 'none';
    setTimeout(() => {
        display.style.animation = 'countPulse 0.5s ease';
    }, 10);
}

// Hide count-in display
function hideCountIn() {
    document.getElementById('countInDisplay').classList.add('hidden');
}

// Show song cue
function showSongCue(text, countdown) {
    const cueElement = document.getElementById('songCue');
    const cueText = document.getElementById('cueText');
    const cueCountdownEl = document.getElementById('cueCountdown');
    
    cueText.textContent = text;
    cueElement.classList.remove('hidden');
    
    if (countdown) {
        const timeSignature = document.getElementById('timeSignature').value;
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        cueCountdown = beatsPerBar;
        cueCountdownEl.textContent = cueCountdown;
    } else {
        cueCountdownEl.textContent = '';
    }
}

function hideSongCue() {
    document.getElementById('songCue').classList.add('hidden');
    cueCountdown = 0;
}

function updateCueCountdown() {
    if (cueCountdown > 0) {
        const cueCountdownEl = document.getElementById('cueCountdown');
        
        if (cueCountdown === 1) {
            cueCountdownEl.textContent = 'NOW!';
        } else {
            cueCountdownEl.textContent = cueCountdown - 1;
        }
        
        cueCountdown--;
        
        if (cueCountdown === 0) {
            setTimeout(() => hideSongCue(), 500);
        }
    }
}

// Display chord progression
// Display chord progression
function displayProgression() {
    if (!currentSong) return;
    
    const display = document.getElementById('progressionDisplay');
    
    if (progressionIndex >= currentSong.progression.length) {
        document.getElementById('currentChordSmall').textContent = 'Complete! üéâ';
        return;
    }
    
    createBeatGrid();
    
    // Use personalized beat grid if chords are selected
    if (selectedChords.length > 0) {
        updateBeatGridPersonalized();
    } else {
        updateBeatGrid();
    }
    
    display.classList.remove('hidden');
}

// Load song
// Load song
function loadSong(songKey) {
    if (!songKey) {
        currentSong = null;
        songMode = false;
        progressionIndex = 0;
        selectedChords = [];
        isChordSelectionMode = false;
        document.getElementById('chordSelectionSection').style.display = 'none';
        document.getElementById('progressionDisplay').classList.add('hidden');
        // Reset to default chords
        displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']);
        return;
    }
    
    currentSong = songs[songKey];
    songMode = true;
    progressionIndex = 0;
    selectedChords = [];
    
    document.getElementById('bpm').value = currentSong.bpm;
    document.getElementById('timeSignature').value = currentSong.timeSignature;
    
    // Show chord selection UI
    showChordSelection(currentSong.chords);
    
    // Hide progression display until ready
    document.getElementById('progressionDisplay').classList.add('hidden');
}

// Display chord buttons based on song
function displayChordButtons(chordList) {
    const buttonContainer = document.querySelector('.chord-buttons');
    buttonContainer.innerHTML = '';
    
    chordList.forEach(chordName => {
        const button = document.createElement('button');
        button.className = 'chord-btn';
        button.setAttribute('data-chord', chordName);
        button.textContent = chordName;
        
        // Add all event listeners
        button.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('mouseup', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('mouseleave', (e) => {
            stopSustain(chordName);
        });
        
        button.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        buttonContainer.appendChild(button);
    });
}

// Show chord selection UI
function showChordSelection(chordList) {
    isChordSelectionMode = true;
    const section = document.getElementById('chordSelectionSection');
    const grid = document.getElementById('chordSelectionGrid');
    
    section.style.display = 'block';
    grid.innerHTML = '';
    
    chordList.forEach(chordName => {
        const item = document.createElement('div');
        item.className = 'chord-select-item';
        item.innerHTML = `
            <input type="checkbox" id="select-${chordName}" value="${chordName}">
            <label for="select-${chordName}">${chordName}</label>
        `;
        
        const checkbox = item.querySelector('input');
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (selectedChords.length < 4) {
                    selectedChords.push(chordName);
                    item.classList.add('selected');
                } else {
                    e.target.checked = false;
                    alert('You can select up to 4 chords only');
                }
            } else {
                selectedChords = selectedChords.filter(c => c !== chordName);
                item.classList.remove('selected');
            }
            updateReadyButton();
        });
        
        grid.appendChild(item);
    });
}

// Update ready button state
function updateReadyButton() {
    const readyBtn = document.getElementById('readyBtn');
    readyBtn.disabled = selectedChords.length === 0;
}

// Hide chord selection and show personalized view
function confirmChordSelection() {
    isChordSelectionMode = false;
    document.getElementById('chordSelectionSection').style.display = 'none';
    
    // Display only selected chord buttons
    displayChordButtons(selectedChords);
    
    // Update beat grid to highlight selected chords
    updateBeatGridPersonalized();
    
    // If in a multi-user room, notify backend of chord selection
    if (socket && socket.connected && currentRoomId && myUserId) {
        socket.emit('update_chords', {
            userId: myUserId,
            chords: selectedChords
        });
        console.log('Sent chord selection to backend:', selectedChords);
    }
}

// ============================================
// BACKEND CONNECTION FUNCTIONS
// ============================================

// Generate a unique user ID
function generateUserId() {
    return 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
}

// Connect to backend via Socket.io
function connectToBackend() {
    if (socket && socket.connected) {
        console.log('Already connected to backend');
        return;
    }
    
    socket = io(BACKEND_URL, {
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000
    });
    
    // Connection established
    socket.on('connect', () => {
        console.log('Connected to backend:', socket.id);
    });
    
    // Connection error
    socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        alert('Failed to connect to server. Please try again.');
    });
    
    // Disconnected
    socket.on('disconnect', (reason) => {
        console.log('Disconnected from backend:', reason);
        if (reason === 'io server disconnect') {
            // Server disconnected us, try to reconnect
            socket.connect();
        }
    });
    
    // Setup event listeners
    setupSocketListeners();
}

// Setup all socket event listeners
function setupSocketListeners() {
    if (!socket) return;
    
    // Room joined successfully
    socket.on('room_joined', (data) => {
        console.log('Room joined:', data);
        currentRoomId = data.room.roomId;
        currentRoomPin = data.room.pin;
        connectedUsers = data.room.users;
        
        // Update UI
        showRoomInfo();
        updateUserList(data.room.users);
        
        alert(`Successfully joined room! PIN: ${currentRoomPin}`);
    });
    
    // User joined the room
    socket.on('user_joined', (data) => {
        console.log('User joined:', data.user);
        
        // Show notification
        if (data.user.userId !== myUserId) {
            showNotification(`${data.user.name} joined the room`);
        }
    });
    
    // User left the room
    socket.on('user_left', (data) => {
        console.log('User left:', data.userId);
        showNotification(`User left the room`);
    });
    
    // User list updated
    socket.on('user_list_updated', (data) => {
        console.log('User list updated:', data.users);
        connectedUsers = data.users;
        updateUserList(data.users);
    });
    
    // User chords updated
    socket.on('user_chords_updated', (data) => {
        console.log('User chords updated:', data);
        // Update UI if needed
    });
    
    // Playback started (synchronized)
    socket.on('playback_started', (data) => {
        console.log('Playback started:', data);
        
        if (myRole === 'guest') {
            // Guest receives synchronized playback command
            const { songId, bpm, startTimestamp } = data;
            
            // Make sure the song is loaded and beat grid is ready
            if (!currentSong || !songMode) {
                console.error('Guest: Song not loaded properly');
                return;
            }
            
            // Ensure beat grid is displayed
            const display = document.getElementById('progressionDisplay');
            if (display.classList.contains('hidden')) {
                displayProgression();
            }
            
            // Calculate delay until start time
            const now = Date.now();
            const delay = startTimestamp - now;
            
            console.log(`Sync: Starting in ${delay}ms at timestamp ${startTimestamp}`);
            
            if (delay > 0) {
                // Wait until the exact start time, then begin
                setTimeout(() => {
                    startCountInSynced(bpm);
                }, delay);
            } else {
                // We're late, start immediately
                console.warn('Late to the party, starting immediately');
                startCountInSynced(bpm);
            }
        }
    });
    
    // Playback stopped
    socket.on('playback_stopped', (data) => {
        console.log('Playback stopped');
        
        if (myRole === 'guest') {
            stopMetronome();
            alert('Host stopped playback');
        }
    });
    
    // Beat update (sync from host)
    socket.on('beat_update', (data) => {
        // Guests receive beat updates to stay in sync
        // This will be used for tight synchronization
    });
    
    // Room closed
    socket.on('room_closed', (data) => {
        alert(data.message);
        leaveRoom();
    });
    
    // Error from server
    socket.on('error', (data) => {
        console.error('Server error:', data);
        alert('Error: ' + data.message);
    });
}

// ============================================
// ROOM MANAGEMENT FUNCTIONS
// ============================================

// Create a new room (Host)
async function createRoom() {
    try {
        myUserId = generateUserId();
        myRole = 'host';
        
        const response = await fetch(`${BACKEND_URL}/api/room/create`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ hostId: myUserId })
        });
        
        const data = await response.json();
        
        if (data.success) {
            currentRoomId = data.roomId;
            currentRoomPin = data.pin;
            
            console.log('Room created:', data);
            
            // Connect to backend and join room via WebSocket
            connectToBackend();
            
            // Wait for socket to connect, then join room
            setTimeout(() => {
                socket.emit('join_room', {
                    roomId: currentRoomId,
                    userId: myUserId,
                    role: 'host'
                });
            }, 500);
            
        } else {
            alert('Failed to create room: ' + (data.error || 'Unknown error'));
        }
        
    } catch (error) {
        console.error('Error creating room:', error);
        alert('Failed to create room. Please try again.');
    }
}

// Join an existing room (Guest)
async function joinRoom(pin) {
    try {
        myUserId = generateUserId();
        myRole = 'guest';
        
        const response = await fetch(`${BACKEND_URL}/api/room/join`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ 
                pin: pin,
                userId: myUserId 
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            currentRoomId = data.roomId;
            currentRoomPin = data.pin;
            
            console.log('Room found:', data);
            
            // Connect to backend and join room via WebSocket
            connectToBackend();
            
            // Wait for socket to connect, then join room
            setTimeout(() => {
                socket.emit('join_room', {
                    roomId: currentRoomId,
                    userId: myUserId,
                    role: 'guest'
                });
            }, 500);
            
        } else {
            alert('Failed to join room: ' + (data.error || 'Room not found'));
        }
        
    } catch (error) {
        console.error('Error joining room:', error);
        alert('Failed to join room. Please check the PIN and try again.');
    }
}

// Leave room
function leaveRoom() {
    if (socket && currentRoomId) {
        socket.emit('leave_room');
    }
    
    // Reset state
    currentRoomId = null;
    currentRoomPin = null;
    myRole = null;
    connectedUsers = [];
    
    // Disconnect socket
    if (socket) {
        socket.disconnect();
        socket = null;
    }
    
    // Reset UI
    hideRoomInfo();
    document.getElementById('roomControls').style.display = 'grid';
}

// Show room info UI
function showRoomInfo() {
    document.getElementById('roomControls').style.display = 'none';
    document.getElementById('roomInfo').classList.remove('hidden');
    document.getElementById('pinCode').textContent = currentRoomPin;
    
    // Disable START button for guests (only host can start)
    const startBtn = document.getElementById('startBtn');
    if (myRole === 'guest') {
        startBtn.disabled = true;
        startBtn.textContent = '‚è≥ Waiting for Host...';
        startBtn.style.opacity = '0.6';
        startBtn.style.cursor = 'not-allowed';
    } else {
        startBtn.disabled = false;
        startBtn.textContent = '‚ñ∂ START COUNT-IN';
        startBtn.style.opacity = '1';
        startBtn.style.cursor = 'pointer';
    }
}

// Hide room info UI
function hideRoomInfo() {
    document.getElementById('roomControls').style.display = 'grid';
    document.getElementById('roomInfo').classList.add('hidden');
    document.getElementById('userList').innerHTML = '';
    document.getElementById('userCount').textContent = '0';
    
    // Re-enable START button
    const startBtn = document.getElementById('startBtn');
    startBtn.disabled = false;
    startBtn.textContent = '‚ñ∂ START COUNT-IN';
    startBtn.style.opacity = '1';
    startBtn.style.cursor = 'pointer';
}

// Update user list display
function updateUserList(users) {
    const userList = document.getElementById('userList');
    const userCount = document.getElementById('userCount');
    
    userList.innerHTML = '';
    userCount.textContent = users.length;
    
    users.forEach(user => {
        const userItem = document.createElement('div');
        userItem.className = 'user-item' + (user.role === 'host' ? ' host' : '');
        
        const chordsHtml = user.assignedChords.length > 0 
            ? user.assignedChords.map(chord => 
                `<span class="user-chord-tag">${chord}</span>`
              ).join('')
            : '<span style="opacity: 0.6; font-size: 12px;">No chords selected</span>';
        
        userItem.innerHTML = `
            <div class="user-info">
                <div class="user-name">
                    ${user.name} ${user.role === 'host' ? 'üëë' : ''}
                    ${user.userId === myUserId ? '(You)' : ''}
                </div>
                <div class="user-details">
                    ${user.instrument} ‚Ä¢ ${chordsHtml}
                </div>
            </div>
        `;
        
        userList.appendChild(userItem);
    });
}

// Show notification
function showNotification(message) {
    // Simple alert for now, can be upgraded to toast notification
    console.log('Notification:', message);
}

// Check and show cue
function checkAndShowCue() {
    if (!songMode || !currentSong) return;
    
    if (progressionIndex >= currentSong.progression.length) return;
    
    const item = currentSong.progression[progressionIndex];
    
    if (typeof item === 'object' && item.cue) {
        // Just advance past the cue, no overlay needed
        progressionIndex++;
        displayProgression();
    }
}

// Advance progression
// Advance progression
function advanceProgression() {
    if (!songMode || !currentSong) return;
    
    progressionIndex++;
    
    if (progressionIndex >= currentSong.progression.length) {
        displayProgression();
        return;
    }
    
    checkAndShowCue();
    // Update the grid with new upcoming chords
	if (selectedChords.length > 0) {
		updateBeatGridPersonalized();
	} else {
		updateBeatGrid();
	}
}

// Check song chord
function checkSongChord(chordName) {
    if (!songMode || !currentSong) return true;
    
    if (progressionIndex >= currentSong.progression.length) return false;
    
    const expectedItem = currentSong.progression[progressionIndex];
    
    if (typeof expectedItem === 'object' && expectedItem.cue) {
        return false;
    }
    
    // Handle new structure with beat information
    const expectedChord = typeof expectedItem === 'object' ? expectedItem.chord : expectedItem;
    
    if (chordName === expectedChord) {
        advanceProgression();
        return true;
    }
    
    advanceProgression();
    return false;
}


// Handle chord sustain (hold to play)
function startSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Stop any previous sustained chord
    if (sustainedChord) {
        const notes = chordDefinitions[sustainedChord];
        sustainSynth.triggerRelease(notes);
    }
    
    sustainedChord = chordName;
    const button = document.querySelector(`[data-chord="${chordName}"]`);
    button.classList.add('playing');
    
    // Play immediately with attack on the sustain synth
    const notes = chordDefinitions[chordName];
    sustainSynth.triggerAttack(notes, Tone.now());
}

function stopSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Only release if this is the currently sustained chord
    if (sustainedChord === chordName) {
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.remove('playing');
        
        // Release the notes on the sustain synth
        const notes = chordDefinitions[chordName];
        sustainSynth.triggerRelease(notes, Tone.now());
        
        sustainedChord = null;
    }
}

// Start count-in
function startCountIn() {
    isCountingIn = true;
    waitingForFirstChord = false;
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = (60 / bpm) * 1000;
    
    let countBeat = 1;
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    
    showCountIn(countBeat);
    countBeat++;
    
    const countInterval = setInterval(() => {
        if (countBeat <= beatsPerBar) {
            showCountIn(countBeat);
            countBeat++;
        } else {
            clearInterval(countInterval);
            hideCountIn();
            isCountingIn = false;
            waitingForFirstChord = true;
            
            startMetronomeWaiting();
            
            if (songMode) {
                checkAndShowCue();
            }
        }
    }, beatDuration);
}

async function startCountInSynced(bpm) {
    console.log('Guest: Starting synchronized count-in');
    
    // Ensure Tone.js is ready
    if (Tone.context.state !== 'running') {
        console.log('Guest: Tone context not running, starting it');
        await Tone.start();
    }
    console.log('Guest: Tone context state:', Tone.context.state, 'Tone.now():', Tone.now());
    
    // Set all necessary flags
    isCountingIn = true;
    waitingForFirstChord = false;
    isPlaying = true;
    isScheduling = false; // Reset scheduling flag
    
    // Sync settings from host
    document.getElementById('bpm').value = bpm;
    const timeSignature = document.getElementById('timeSignature').value;
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = (60 / bpm) * 1000;
    
    // Make sure beat grid is visible and ready
    createBeatGrid();
    if (selectedChords.length > 0) {
        updateBeatGridPersonalized();
    } else {
        updateBeatGrid();
    }
    
    let countBeat = 1;
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    
    showCountIn(countBeat);
    countBeat++;
    
    const countInterval = setInterval(() => {
        if (countBeat <= beatsPerBar) {
            showCountIn(countBeat);
            countBeat++;
        } else {
            clearInterval(countInterval);
            hideCountIn();
            isCountingIn = false;
            
            // CRITICAL: Ensure Tone.js is started and give it time to stabilize
            Tone.start().then(() => {
                console.log('Guest: Tone.js started, Tone.now():', Tone.now());
                
                // Small delay to let Tone stabilize
                setTimeout(() => {
                    // Reset ALL timing variables
                    currentBeatIndex = 0;
                    beatsPlayedInBar = 0;
                    chordStartBeatIndex = -1;
                    currentChord = null;
                    nextChord = null;
                    
                    // Initialize timing based on CURRENT Tone time
                    const now = Tone.now();
                    nextBeatTime = now;
                    
                    console.log('Guest: Initializing - Tone.now():', now, 'nextBeatTime:', nextBeatTime, 'currentBeatIndex:', currentBeatIndex);
                    
                    // Start scheduling
                    isScheduling = true;
                    scheduleMetronome();
                    
                    if (songMode) {
                        checkAndShowCue();
                    }
                }, 100); // 100ms delay for Tone to stabilize
            });
        }
    }, beatDuration);
}

// Start metronome in waiting mode
function startMetronomeWaiting() {
    console.log('startMetronome called - isScheduling will be set to true'); // ADD THIS

    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now();
    
    isScheduling = true;
    console.log('startMetronome - isScheduling now true, calling scheduleMetronome()'); // ADD THIS

    scheduleMetronome();
}

function startMetronome() {
    console.log('startMetronome called - isScheduling will be set to true');
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now(); // This should always use current Tone time
    
    console.log('startMetronome - nextBeatTime set to:', nextBeatTime, 'Tone.now():', Tone.now());
    
    isScheduling = true;
    console.log('startMetronome - isScheduling now true, calling scheduleMetronome()');
    scheduleMetronome();
}

// Precise scheduling function using Tone.js timing
function scheduleMetronome() {
    if (!isScheduling) {
        console.log('scheduleMetronome called but isScheduling is false, returning');
        return;
    }
    
    // ADD THIS CHECK
    if (currentBeatIndex === 0 && nextBeatTime > Tone.now() + 1.0) {
        console.log('FIXING: nextBeatTime is too far in future, resetting to now');
        nextBeatTime = Tone.now();
    }
    
    console.log('scheduleMetronome running - currentBeatIndex:', currentBeatIndex, 'isPlaying:', isPlaying);
	
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    const quarterNoteDuration = 60 / bpm;
    const repeatMode = document.getElementById('repeatMode').checked;
    
    const now = Tone.now();
    const lookAhead = 0.1;
    //added this line
	console.log('NextBeatTime: ', nextBeatTime, ' Now: ', now, 'Look Ahead: ', lookAhead);
	
    while (nextBeatTime < now + lookAhead) {
        const beatIndex = currentBeatIndex;
        const beatTime = nextBeatTime;
        
        // Calculate which beat within the bar for the checkbox highlighting
        const beatInBar = currentBeatIndex % division;
        
        const visualOffset = 0.05;
        Tone.Draw.schedule(() => {
            console.log('Visual update - beatInBar:', beatInBar, 'beatIndex:', beatIndex); // ADD THIS

            updateMetronome(beatInBar);  // Use beatInBar for checkbox highlighting
            
            // Highlight beat in grid using absolute position
            console.log('Calling highlightBeatInGrid with:', beatIndex); // ADD THIS
	
            highlightBeatInGrid(beatIndex);
            
            const currentQuarterBeat = Math.floor((beatIndex * noteDuration) / quarterNoteDuration);
            const prevQuarterBeat = beatIndex === 0 ? -1 : Math.floor(((beatIndex - 1) * noteDuration) / quarterNoteDuration);
            
            if (cueCountdown > 0 && currentQuarterBeat !== prevQuarterBeat) {
                updateCueCountdown();
            }
        }, beatTime - visualOffset);
        
        const checkboxes = document.querySelectorAll('.checkboxes-grid input[type="checkbox"]');
		const shouldPlay = currentChord && checkboxes[beatInBar] && checkboxes[beatInBar].checked;
		const immediateMode = document.getElementById('immediateMode').checked;

		// Only play from metronome if NOT in immediate mode
		if (shouldPlay && !immediateMode) {
			if (repeatMode || beatsPlayedInBar < division) {
				const notes = chordDefinitions[currentChord];
				const playDuration = noteDuration * 0.9;
				synth.triggerAttackRelease(notes, playDuration, beatTime);
			}
		}

		nextBeatTime += noteDuration;
		currentBeatIndex++;
        console.log('Incremented currentBeatIndex to:', currentBeatIndex, 'nextBeatTime:', nextBeatTime); // ADD THIS


		if (currentChord && !immediateMode) {
			beatsPlayedInBar++;
		}
        
        // Check if we've completed a bar
		// Check if we've completed a bar
		if (beatInBar === division - 1) {
			// In song mode with immediate response, don't auto-clear the chord
			const immediateMode = document.getElementById('immediateMode').checked;
			
			// Clear chord after one bar in immediate mode without repeat
			if (immediateMode && !repeatMode && currentChord) {
				const barsPlayed = Math.floor(beatsPlayedInBar / division);
				if (barsPlayed >= 1) {
					Tone.Draw.schedule(() => {
						currentChord = null;
						updateChordDisplay(null);
						beatsPlayedInBar = 0;
					}, beatTime);
				}
			}
			
			if (!repeatMode && !songMode && !immediateMode && beatsPlayedInBar >= division) {
				Tone.Draw.schedule(() => {
					currentChord = null;
					updateChordDisplay(null);
				}, beatTime);
			}
			
			// Only switch to nextChord if it was explicitly set (not in song mode with immediate)
			if (nextChord && !immediateMode) {
				currentChord = nextChord;
				nextChord = null;
				beatsPlayedInBar = 0;
				Tone.Draw.schedule(() => {
					updateChordDisplay(currentChord);
				}, beatTime);
			}
		}
    }
    
    requestAnimationFrame(scheduleMetronome);
}

// Find stopMetronome() and add these lines at the beginning:
function stopMetronome() {
    isScheduling = false;
    document.getElementById('beatGridContainer').scrollLeft = 0;
    chordStartBeatIndex = -1
    
	// ADD THESE TWO NEW LINES:
    // Reset chord selection if in selection mode
    if (isChordSelectionMode) {
        document.getElementById('chordSelectionSection').style.display = 'none';
        selectedChords = [];
        isChordSelectionMode = false;
    }
	
    if (metronomeInterval) {
        clearInterval(metronomeInterval);
        metronomeInterval = null;
    }
    updateMetronome(-1);
    hideCountIn();
    hideSongCue();
    isPlaying = false;
    isCountingIn = false;
    waitingForFirstChord = false;
    currentChord = null;
    nextChord = null;
    updateChordDisplay(null);
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('startBtn').disabled = false;
    
    if (songMode && currentSong) {
        progressionIndex = 0;
        displayProgression();
    }
}

// Handle chord click
/*async function handleChordClick(chordName) {
    await Tone.start();
	
	// ADD THIS BLOCK - Handle guest clicks before host starts
    if (myRole === 'guest' && !isPlaying && !isCountingIn) {
        // Guest clicked before host started - just ignore or show friendly message
        console.log('Waiting for host to start playback');
        return; // Don't do anything, just wait for host
    }
    
    const sustainMode = document.getElementById('sustainMode').checked;
    
    if (sustainMode) {
        startSustain(chordName);
        updateChordDisplay(chordName);
        return;
    }
    
    if (songMode) {
        const isCorrect = checkSongChord(chordName);
        
        if (!isCorrect && currentSong) {
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('wrong-chord-flash');
            setTimeout(() => button.classList.remove('wrong-chord-flash'), 500);
        }
    }
    
    const immediateMode = document.getElementById('immediateMode').checked;
    
		if (immediateMode && isPlaying) {
			// Update the chord and play it immediately
			currentChord = chordName;
			updateChordDisplay(chordName);
			
			// Track when this chord was clicked (absolute beat position)
			chordStartBeatIndex = currentBeatIndex;
			
			const bpm = parseInt(document.getElementById('bpm').value);
			const timeSignature = document.getElementById('timeSignature').value;
			const division = parseInt(document.querySelector('input[name="division"]:checked').value);
			const beatsPerBar = parseInt(timeSignature.split('/')[0]);
			const beatDuration = 60 / bpm;
			const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
			
			// Play immediately when clicked
			const notes = chordDefinitions[chordName];
			synth.triggerAttackRelease(notes, playDuration, Tone.now());
			
			const button = document.querySelector(`[data-chord="${chordName}"]`);
			button.classList.add('playing');
			setTimeout(() => button.classList.remove('playing'), 200);
			
			return;
		}
    
    if (waitingForFirstChord) {
        waitingForFirstChord = false;
        if (!immediateMode) {
            nextChord = chordName;
        } else {
            currentChord = chordName;
            updateChordDisplay(chordName);
        }
        beatsPlayedInBar = 0;
        isPlaying = true;
		} else if (!isPlaying && !isCountingIn) {
			currentChord = chordName;
			updateChordDisplay(chordName);
			beatsPlayedInBar = 0;
			chordStartBeatIndex = 0;
			isPlaying = true;
			startMetronome();  // Always start metronome
			document.getElementById('stopBtn').disabled = false;
			document.getElementById('startBtn').disabled = true;
			
			const sustainMode = document.getElementById('sustainMode').checked;
			
			// Play the first chord immediately if in immediate mode but NOT in sustain mode
			// (In sustain mode, sound only plays when button is held)
			if (immediateMode && !sustainMode) {
				const bpm = parseInt(document.getElementById('bpm').value);
				const timeSignature = document.getElementById('timeSignature').value;
				const division = parseInt(document.querySelector('input[name="division"]:checked').value);
				const beatsPerBar = parseInt(timeSignature.split('/')[0]);
				const beatDuration = 60 / bpm;
				const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
				
				const notes = chordDefinitions[chordName];
				synth.triggerAttackRelease(notes, playDuration, Tone.now());
				
				const button = document.querySelector(`[data-chord="${chordName}"]`);
				button.classList.add('playing');
				setTimeout(() => button.classList.remove('playing'), 200);
			}
		} else if (isPlaying && !immediateMode) {
        nextChord = chordName;
    }
}*/

async function handleChordClick(chordName) {
    await Tone.start();
    
    const sustainMode = document.getElementById('sustainMode').checked;
    const immediateMode = document.getElementById('immediateMode').checked;
    
    // In sustain mode, handle the sound separately
    if (sustainMode) {
        startSustain(chordName);
        updateChordDisplay(chordName);
        
        // If metronome isn't running yet, start it (for visual beat guidance)
        if (!isPlaying && !isCountingIn) {
            currentChord = chordName;
            beatsPlayedInBar = 0;
            chordStartBeatIndex = 0;
            isPlaying = true;
            startMetronome();
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('startBtn').disabled = true;
        }
        
        return; // Don't continue to the immediate/normal playback logic
    }
    
    if (songMode) {
        const isCorrect = checkSongChord(chordName);
        
        if (!isCorrect && currentSong) {
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('wrong-chord-flash');
            setTimeout(() => button.classList.remove('wrong-chord-flash'), 500);
        }
    }
    
    if (immediateMode && isPlaying) {
        // Update the chord and play it immediately
        currentChord = chordName;
        updateChordDisplay(chordName);
        
        // Track when this chord was clicked (absolute beat position)
        chordStartBeatIndex = currentBeatIndex;
        
        const bpm = parseInt(document.getElementById('bpm').value);
        const timeSignature = document.getElementById('timeSignature').value;
        const division = parseInt(document.querySelector('input[name="division"]:checked').value);
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        const beatDuration = 60 / bpm;
        const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
        
        // Play immediately when clicked
        const notes = chordDefinitions[chordName];
        synth.triggerAttackRelease(notes, playDuration, Tone.now());
        
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.add('playing');
        setTimeout(() => button.classList.remove('playing'), 200);
        
        return;
    }
    
    if (waitingForFirstChord) {
        waitingForFirstChord = false;
        if (!immediateMode) {
            nextChord = chordName;
        } else {
            currentChord = chordName;
            updateChordDisplay(chordName);
        }
        beatsPlayedInBar = 0;
        isPlaying = true;
    } else if (!isPlaying && !isCountingIn) {
        currentChord = chordName;
        updateChordDisplay(chordName);
        beatsPlayedInBar = 0;
        chordStartBeatIndex = 0;
        isPlaying = true;
        startMetronome();
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('startBtn').disabled = true;
        
        // Play the first chord immediately if in immediate mode
        if (immediateMode) {
            const bpm = parseInt(document.getElementById('bpm').value);
            const timeSignature = document.getElementById('timeSignature').value;
            const division = parseInt(document.querySelector('input[name="division"]:checked').value);
            const beatsPerBar = parseInt(timeSignature.split('/')[0]);
            const beatDuration = 60 / bpm;
            const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
            
            const notes = chordDefinitions[chordName];
            synth.triggerAttackRelease(notes, playDuration, Tone.now());
            
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('playing');
            setTimeout(() => button.classList.remove('playing'), 200);
        }
    } else if (isPlaying && !immediateMode) {
        nextChord = chordName;
    }
}

// Event listeners
document.getElementById('songSelect').addEventListener('change', (e) => {
    loadSong(e.target.value);
});

document.getElementById('instrument').addEventListener('change', (e) => {
    const instrument = e.target.value;
    initSynth(instrument);
    
    // If in a multi-user room, notify backend of instrument change
    if (socket && socket.connected && currentRoomId && myUserId) {
        socket.emit('update_instrument', {
            userId: myUserId,
            instrument: instrument
        });
        console.log('Sent instrument change to backend:', instrument);
    }
});

document.querySelectorAll('input[name="division"]').forEach(radio => {
    radio.addEventListener('change', () => {
        updateCheckboxes();
        if (isPlaying) {
            startMetronome();
        }
    });
});

document.getElementById('bpm').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.getElementById('timeSignature').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.querySelectorAll('.chord-btn').forEach(btn => {
    btn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseleave', (e) => {
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
});

document.getElementById('startBtn').addEventListener('click', async () => {
    await Tone.start();
    
    // If host in a room, broadcast synchronized start
    if (myRole === 'host' && socket && socket.connected && currentRoomId) {
        const bpm = parseInt(document.getElementById('bpm').value);
        const songId = document.getElementById('songSelect').value;
        
        // Calculate start time: 2 seconds from now for network buffer
        const startTimestamp = Date.now() + 2000;
        
        console.log('Host broadcasting playback start at timestamp:', startTimestamp);
        
        // Broadcast to all guests
        socket.emit('start_playback', {
            songId: songId,
            bpm: bpm,
            startTimestamp: startTimestamp
        });
        
        // Host also waits for the same timestamp
        setTimeout(() => {
            startCountIn();
        }, 2000);
        
    } else {
        // Single player or guest mode
        startCountIn();
    }
});

document.getElementById('stopBtn').addEventListener('click', () => {
    // If host in a room, broadcast stop to all
    if (myRole === 'host' && socket && socket.connected && currentRoomId) {
        socket.emit('stop_playback');
        console.log('Host broadcasting playback stop');
    }
    
    stopMetronome();
});

document.getElementById('readyBtn').addEventListener('click', () => {
    confirmChordSelection();
    displayProgression();
});

// ============================================
// MULTI-USER UI EVENT LISTENERS
// ============================================

// Create Room button
document.getElementById('createRoomBtn').addEventListener('click', () => {
    createRoom();
});

// Join Room button
document.getElementById('joinRoomBtn').addEventListener('click', () => {
    // Show modal
    document.getElementById('joinRoomModal').classList.remove('hidden');
    document.getElementById('joinPinInput').value = '';
    document.getElementById('joinPinInput').focus();
});

// Cancel join button
document.getElementById('cancelJoinBtn').addEventListener('click', () => {
    document.getElementById('joinRoomModal').classList.add('hidden');
});

// Confirm join button
document.getElementById('confirmJoinBtn').addEventListener('click', () => {
    const pin = document.getElementById('joinPinInput').value.trim();
    
    if (pin.length !== 6) {
        alert('Please enter a valid 6-digit PIN');
        return;
    }
    
    document.getElementById('joinRoomModal').classList.add('hidden');
    joinRoom(pin);
});

// Allow Enter key in PIN input
document.getElementById('joinPinInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('confirmJoinBtn').click();
    }
});

// Copy PIN button
document.getElementById('copyPinBtn').addEventListener('click', () => {
    const pin = document.getElementById('pinCode').textContent;
    
    navigator.clipboard.writeText(pin).then(() => {
        const btn = document.getElementById('copyPinBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úì Copied!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy:', err);
        alert('PIN: ' + pin);
    });
});

// Leave Room button
document.getElementById('leaveRoomBtn').addEventListener('click', () => {
    if (confirm('Are you sure you want to leave the room?')) {
        leaveRoom();
    }
});
// Initialize
initSynth('guitar');
updateCheckboxes();
displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']);
createBeatGrid(); // Add this line
    </script>
</body>
</html>
