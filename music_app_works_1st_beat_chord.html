<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

h1 {
    text-align: center;
    color: #667eea;
    margin-bottom: 30px;
    font-size: 2em;
}



.control-group:last-child {
    margin-bottom: 0;
}

label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
}

select, input[type="number"] {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s;
}

select:focus, input[type="number"]:focus {
    outline: none;
    border-color: #667eea;
}



.radio-group {
    display: flex;
    gap: 15px;
    margin-top: 8px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 5px;
}

.radio-option input[type="radio"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.checkboxes-container {
    margin-top: 15px;
    padding: 15px;
    background: white;
    border-radius: 8px;
    border: 2px solid #e0e0e0;
}

.checkboxes-grid {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.checkbox-item {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 8px 12px;
    border-radius: 6px;
    transition: all 0.1s;
}

.checkbox-item.active {
    background: #667eea;
    color: white;
    transform: scale(1.1);
}

.checkbox-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

@keyframes countPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.count-in-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    text-align: center;
    padding: 30px;
    background: linear-gradient(135deg, #ffd43b 0%, #fab005 100%);
    border-radius: 15px;
    color: white;
    font-size: 72px;
    font-weight: bold;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 212, 59, 0.4);
    animation: countPulse 0.5s ease;
}

.count-in-display.hidden {
    display: none !important;
}

.song-cue {
    position: fixed;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    text-align: center;
    padding: 15px 40px;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    border-radius: 0 0 15px 15px;
    color: white;
    font-size: 24px;
    font-weight: bold;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.5);
    animation: cuePulse 0.8s ease infinite;
    max-width: 80%;
}
.song-cue.hidden {
    display: none !important;
}

.song-cue .countdown {
    font-size: 20px;
    margin-top: 5px;
}

@keyframes cuePulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.9; }
}



.progression-display {
    display: flex;
    gap: 20px;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
}

.progression-display.hidden {
    display: none !important;
}

.chord-box {
    flex: 1;
    max-width: 350px;
    text-align: center;
    min-width: 250px;
}

.chord-box .label {
    font-size: 14px;
    color: #666;
    margin-bottom: 10px;
    text-transform: uppercase;
    font-weight: 600;
}

.chord-box .chord-value {
    display: inline-block;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 48px;
    font-weight: bold;
}

.chord-box.current .chord-value {
    background: #dee2e6;
    color: #495057;
    font-size: 32px;
    padding: 15px 30px;
}

.chord-box.next .chord-value {
    background: #ffc107;
    color: #000;
}


.chords-section h2 {
    color: #667eea;
    margin-bottom: 20px;
    text-align: center;
}




.chord-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}

.chord-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
}

.chord-btn.playing {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    animation: pulse 0.3s ease;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.controls-section {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 15px;
    margin-bottom: 15px;
}

.control-group {
    margin-bottom: 10px;
}

.controls-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.controls-row-three {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
    margin-bottom: 10px;
}

.rhythm-controls {
    display: contents;
}

.rhythm-group {
    min-width: auto;
}

.checkboxes-row {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
    flex-wrap: wrap;
}

.checkboxes-row label {
    display: inline;
    margin-bottom: 0;
    font-weight: 500;
    font-size: 14px;
}

.progression-container {
    margin: 15px 0;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 10px;
}

.chords-section {
    margin-top: 15px;
}

.chord-buttons {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.chord-btn {
    padding: 30px;
    font-size: 24px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

.control-buttons {
    display: flex;
    gap: 15px;
    margin-top: 15px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

.start-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #51cf66 0%, #2f9e44 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(81, 207, 102, 0.4);
}

.start-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(81, 207, 102, 0.6);
}

.start-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(81, 207, 102, 0.4);
}

.start-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.start-btn:disabled:hover {
    transform: none;
}

.stop-btn {
    flex: 1;
    padding: 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
    color: white;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
}

.stop-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
}

.stop-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
}

.stop-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    box-shadow: none;
}

.stop-btn:disabled:hover {
    transform: none;
}

.wrong-chord-flash {
    animation: wrongFlash 0.5s ease;
}

@keyframes wrongFlash {
    0%, 100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    50% { background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); }
}
@keyframes nextChordFlash {
    0%, 100% { 
        background: #ffc107;
        transform: scale(1);
    }
    50% { 
        background: #51cf66;
        transform: scale(1.1);
    }
}

.chord-box.next .chord-value.flash {
    animation: nextChordFlash 0.4s ease;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Chord Player</h1>
        
        <div class="controls-section">
			<div class="controls-row">
				<div class="control-group">
					<label for="songSelect">Song:</label>
					<select id="songSelect">
						<option value="">-- Select a Song --</option>
						<option value="inthandam">Inthandam</option>
						<option value="ChinniChinni">Chinni Chinni Aasa</option>
					</select>
				</div>

				<div class="control-group">
					<label for="instrument">Instrument:</label>
					<select id="instrument">
						<option value="guitar">Guitar</option>
						<option value="violin">Violin</option>
						<option value="pads">Pads</option>
					</select>
				</div>
			</div>

			<div class="controls-row-three">
				<div class="control-group">
					<label for="bpm">BPM:</label>
					<input type="number" id="bpm" value="120" min="40" max="240">
				</div>

				<div class="control-group">
					<label for="timeSignature">Time Signature:</label>
					<select id="timeSignature">
						<option value="4/4">4/4</option>
						<option value="3/4">3/4</option>
					</select>
				</div>

				<div class="control-group">
					<label>Note Division:</label>
					<div class="radio-group">
						<div class="radio-option">
							<input type="radio" name="division" value="4" id="div4" checked>
							<label for="div4">4</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="8" id="div8">
							<label for="div8">8</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="16" id="div16">
							<label for="div16">16</label>
						</div>
						<div class="radio-option">
							<input type="radio" name="division" value="32" id="div32">
							<label for="div32">32</label>
						</div>
					</div>
				</div>
			</div>

			<div class="checkboxes-row">
				<label>
					<input type="checkbox" id="immediateMode" checked>
					Immediate Response Mode
				</label>
				<label>
					<input type="checkbox" id="repeatMode">
					Repeat
				</label>
				<label>
					<input type="checkbox" id="sustainMode">
					Sustain
				</label>
			</div>

			<div class="checkboxes-container">
				<div class="checkboxes-grid" id="checkboxesGrid"></div>
			</div>
		</div>

        <div class="count-in-display hidden" id="countInDisplay"></div>

        <div class="song-cue hidden" id="songCue">
            <div id="cueText"></div>
            <div class="countdown" id="cueCountdown"></div>
        </div>

        <div class="progression-container">
            <div id="progressionDisplay" class="progression-display hidden">
                <div class="chord-box current">
                    <div class="label">Currently Playing</div>
                    <div class="chord-value" id="currentChordDisplay2">--</div>
                </div>
                <div class="chord-box next">
                    <div class="label">Next Chord to Play</div>
                    <div class="chord-value" id="nextChordDisplay">--</div>
                </div>
            </div>
        </div>

        <div class="chords-section">
            <h2>Chords</h2>
            <div class="chord-buttons"></div>
            <div class="control-buttons">
                <button class="start-btn" id="startBtn">‚ñ∂ START COUNT-IN</button>
                <button class="stop-btn" id="stopBtn" disabled>‚èπ STOP</button>
            </div>
        </div>
    </div>

    <script>
        // Chord definitions (note names for each chord)
const chordDefinitions = {
    'E': ['E3', 'G#3', 'B3', 'E4'],
    'B': ['B3', 'D#4', 'F#4', 'B4'],
    'G#m': ['G#3', 'B3', 'D#4', 'G#4'],
    'C#m': ['C#3', 'E3', 'G#3', 'C#4'],
    'A': ['A3', 'C#4', 'E4', 'A4'],
    'F#m': ['F#3', 'A3', 'C#4', 'F#4'],
    'Eb': ['Eb3', 'G3', 'Bb3', 'Eb4'],
    'Ab': ['Ab3', 'C4', 'Eb4', 'Ab4'],
    'Db': ['Db3', 'F3', 'Ab3', 'Db4'],
    'Bb': ['Bb3', 'D4', 'F4', 'Bb4'],
    'Bbm': ['Bb3', 'Db4', 'F4', 'Bb4'],
    'Fm': ['F3', 'Ab3', 'C4', 'F4'],
    'Fm7': ['F3', 'Ab3', 'C4', 'Eb4']
};

// Song definitions - EASY TO ADD/EDIT SONGS HERE
const songs = {
    inthandam: {
        name: 'Inthandam',
        bpm: 200,
        timeSignature: '4/4',
		chords: ['E', 'B', 'G#m', 'C#m', 'A', 'F#m'], 
        progression: [
            // Intro pattern
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            
            // Cue for singing
            { cue: 'Start Singing', countdown: true },
            
            // Verse pattern
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'E', 'C#m', 'C#m',
            'F#m', 'B', 'E', 'E',
            'G#m', 'C#m', 'B', 'B',
            
            // Cue for chorus
            { cue: 'Sing Chorus', countdown: true },
            
            // Chorus
            'E', 'E', 'G#m', 'G#m',
            'C#m', 'C#m', 'B', 'B',
            'E', 'E', 'G#m', 'G#m',
            'E', 'G#m', 'A', 'F#m',
            'B', 'G#m', 'E', 'B',
            'C#m', 'G#m', 'A', 'F#m',
            'A', 'F#m', 'B', 'B'
        ]
    },
	ChinniChinni: {
        name: 'Chinni Chinni Aasa',
        bpm: 176,
        timeSignature: '4/4',
		chords: ['Eb', 'Bb', 'Db', 'Ab', 'Fm', 'Bbm', 'Fm', 'Fm7'], 
        progression: [
            // Intro pattern
            'Eb', 'Eb', 'Eb', 'Ab', 'Eb', 'Ab', 'Eb', 'Db', 
            'Eb', 'Bb',
            
            // Cue for singing
            { cue: 'Start Singing', countdown: true },
            
            // Verse pattern
             
			'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'B', 'E', 'B', 'E', 'B',
            'C#m', 'A',
            'E', 'E', 'C#m', 'C#m',
            'F#m', 'B', 'E', 'E',
            'G#m', 'C#m', 'B', 'B',
            
            // Cue for chorus
            { cue: 'Sing Chorus', countdown: true },
            
            // Chorus
            'E', 'E', 'G#m', 'G#m',
            'C#m', 'C#m', 'B', 'B',
            'E', 'E', 'G#m', 'G#m',
            'E', 'G#m', 'A', 'F#m',
            'B', 'G#m', 'E', 'B',
            'C#m', 'G#m', 'A', 'F#m',
            'A', 'F#m', 'B', 'B'
        ]
    }
};

// State variables
let synth = null;
let sustainSynth = null;
let reverb = null;
let chorus = null;
let compressor = null;
let isPlaying = false;
let isCountingIn = false;
let waitingForFirstChord = false;
let currentChord = null;
let nextChord = null;
let metronomeInterval = null;
let currentBeatIndex = 0;
let barStartTime = null;
let nextBeatTime = null;
let isScheduling = false;
let beatsPlayedInBar = 0;
let sustainedChord = null;
let sustainInterval = null;
let currentSong = null;
let progressionIndex = 0;
let songMode = false;
let cueCountdown = 0;

// Initialize synth based on instrument
function initSynth(instrument) {
    if (synth) synth.dispose();
    if (sustainSynth) sustainSynth.dispose();
    if (reverb) reverb.dispose();
    if (chorus) chorus.dispose();
    if (compressor) compressor.dispose();

    // Create effects chain
    reverb = new Tone.Reverb({
        decay: 2.5,
        wet: 0.3
    }).toDestination();
    
    chorus = new Tone.Chorus({
        frequency: 1.5,
        delayTime: 3.5,
        depth: 0.7,
        wet: 0.3
    }).connect(reverb);
    
    compressor = new Tone.Compressor({
        threshold: -24,
        ratio: 4,
        attack: 0.003,
        release: 0.1
    }).connect(chorus);

    switch(instrument) {
        case 'guitar':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.3, 
                    sustain: 0.4, 
                    release: 1.5 
                },
                volume: -8
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'triangle',
                    partials: [1, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.005, 
                    decay: 0.1, 
                    sustain: 0.8, 
                    release: 0.8 
                },
                volume: -8
            }).connect(compressor);
            break;
            
        case 'violin':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.2, 
                    sustain: 0.7, 
                    release: 0.6 
                },
                volume: -10
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sawtooth',
                    partials: [1, 0.8, 0.6, 0.4, 0.2]
                },
                envelope: { 
                    attack: 0.08, 
                    decay: 0.1, 
                    sustain: 0.9, 
                    release: 0.4 
                },
                volume: -10
            }).connect(compressor);
            break;
            
        case 'pads':
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.4, 
                    decay: 0.3, 
                    sustain: 0.8, 
                    release: 2.5 
                },
                volume: -6
            }).connect(compressor);
            
            sustainSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: 'sine',
                    partials: [1, 0.7, 0.5, 0.3, 0.1]
                },
                envelope: { 
                    attack: 0.3, 
                    decay: 0.2, 
                    sustain: 0.9, 
                    release: 1.5 
                },
                volume: -6
            }).connect(compressor);
            break;
    }
}

// Initialize checkboxes
function updateCheckboxes() {
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const grid = document.getElementById('checkboxesGrid');
    grid.innerHTML = '';

    for (let i = 1; i <= division; i++) {
        const item = document.createElement('div');
        item.className = 'checkbox-item';
        item.innerHTML = `
            <input type="checkbox" id="beat${i}" checked>
            <label for="beat${i}">${i}</label>
        `;
        grid.appendChild(item);
    }
}

// Update visual metronome
function updateMetronome(beatIndex) {
    const items = document.querySelectorAll('.checkbox-item');
    items.forEach((item, i) => {
        if (i === beatIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

// Update current chord display
function updateChordDisplay(chordName) {
    document.getElementById('currentChordDisplay2').textContent = chordName || '--';
}

// Show count-in display
function showCountIn(count) {
    const display = document.getElementById('countInDisplay');
    display.textContent = count;
    display.classList.remove('hidden');
    display.style.animation = 'none';
    setTimeout(() => {
        display.style.animation = 'countPulse 0.5s ease';
    }, 10);
}

// Hide count-in display
function hideCountIn() {
    document.getElementById('countInDisplay').classList.add('hidden');
}

// Show song cue
function showSongCue(text, countdown) {
    const cueElement = document.getElementById('songCue');
    const cueText = document.getElementById('cueText');
    const cueCountdownEl = document.getElementById('cueCountdown');
    
    cueText.textContent = text;
    cueElement.classList.remove('hidden');
    
    if (countdown) {
        const timeSignature = document.getElementById('timeSignature').value;
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        cueCountdown = beatsPerBar;
        cueCountdownEl.textContent = cueCountdown;
    } else {
        cueCountdownEl.textContent = '';
    }
}

function hideSongCue() {
    document.getElementById('songCue').classList.add('hidden');
    cueCountdown = 0;
}

function updateCueCountdown() {
    if (cueCountdown > 0) {
        const cueCountdownEl = document.getElementById('cueCountdown');
        
        if (cueCountdown === 1) {
            cueCountdownEl.textContent = 'NOW!';
        } else {
            cueCountdownEl.textContent = cueCountdown - 1;
        }
        
        cueCountdown--;
        
        if (cueCountdown === 0) {
            setTimeout(() => hideSongCue(), 500);
        }
    }
}

// Display chord progression
function displayProgression() {
    if (!currentSong) return;
    
    const display = document.getElementById('progressionDisplay');
    const nextChordEl = document.getElementById('nextChordDisplay');
    
    if (progressionIndex >= currentSong.progression.length) {
        nextChordEl.textContent = 'Complete! üéâ';
        return;
    }
    
    const nextItem = currentSong.progression[progressionIndex];
    
    if (typeof nextItem === 'object' && nextItem.cue) {
        if (progressionIndex + 1 < currentSong.progression.length) {
            const chordAfterCue = currentSong.progression[progressionIndex + 1];
            if (typeof chordAfterCue === 'string') {
                nextChordEl.textContent = chordAfterCue;
            }
        }
    } else {
        nextChordEl.textContent = nextItem;
    }
    
    display.classList.remove('hidden');
}

// Load song
function loadSong(songKey) {
    if (!songKey) {
        currentSong = null;
        songMode = false;
        progressionIndex = 0;
        document.getElementById('progressionDisplay').classList.add('hidden');
		
		// Reset to default chords
        displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']);
        return;
    }
    
    currentSong = songs[songKey];
    songMode = true;
    progressionIndex = 0;
    
    document.getElementById('bpm').value = currentSong.bpm;
    document.getElementById('timeSignature').value = currentSong.timeSignature;
    
	// Display chord buttons for this song
	displayChordButtons(currentSong.chords);
	 
    displayProgression();
}
// Display chord buttons based on song
function displayChordButtons(chordList) {
    const buttonContainer = document.querySelector('.chord-buttons');
    buttonContainer.innerHTML = '';
    
    chordList.forEach(chordName => {
        const button = document.createElement('button');
        button.className = 'chord-btn';
        button.setAttribute('data-chord', chordName);
        button.textContent = chordName;
        
        // Add all event listeners
        button.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('mouseup', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('mouseleave', (e) => {
            stopSustain(chordName);
        });
        
        button.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleChordClick(chordName);
        });
        
        button.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        button.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopSustain(chordName);
        });
        
        buttonContainer.appendChild(button);
    });
}

// Check and show cue
function checkAndShowCue() {
    if (!songMode || !currentSong) return;
    
    if (progressionIndex >= currentSong.progression.length) return;
    
    const item = currentSong.progression[progressionIndex];
    
    if (typeof item === 'object' && item.cue) {
        showSongCue(item.cue, item.countdown);
        progressionIndex++;
        displayProgression();
    }
}

// Advance progression
// Advance progression
function advanceProgression() {
    if (!songMode || !currentSong) return;
    
    // Flash the next chord display before advancing
    const nextChordEl = document.getElementById('nextChordDisplay');
    nextChordEl.classList.add('flash');
    setTimeout(() => nextChordEl.classList.remove('flash'), 400);
    
    progressionIndex++;
    
    if (progressionIndex >= currentSong.progression.length) {
        displayProgression();
        return;
    }
    
    checkAndShowCue();
    displayProgression();
}
// Check song chord
function checkSongChord(chordName) {
    if (!songMode || !currentSong) return true;
    
    if (progressionIndex >= currentSong.progression.length) return false;
    
    const expectedItem = currentSong.progression[progressionIndex];
    
    if (typeof expectedItem === 'object' && expectedItem.cue) {
        return false;
    }
    
    if (chordName === expectedItem) {
        advanceProgression();
        return true;
    }
    
    advanceProgression();
    return false;
}
// Handle chord sustain (hold to play)
function startSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Stop any previous sustained chord
    if (sustainedChord) {
        const notes = chordDefinitions[sustainedChord];
        sustainSynth.triggerRelease(notes);
    }
    
    sustainedChord = chordName;
    const button = document.querySelector(`[data-chord="${chordName}"]`);
    button.classList.add('playing');
    
    // Play immediately with attack on the sustain synth
    const notes = chordDefinitions[chordName];
    sustainSynth.triggerAttack(notes, Tone.now());
}

function stopSustain(chordName) {
    const sustainMode = document.getElementById('sustainMode').checked;
    if (!sustainMode) return;
    
    // Only release if this is the currently sustained chord
    if (sustainedChord === chordName) {
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.remove('playing');
        
        // Release the notes on the sustain synth
        const notes = chordDefinitions[chordName];
        sustainSynth.triggerRelease(notes, Tone.now());
        
        sustainedChord = null;
    }
}

// Start count-in
function startCountIn() {
    isCountingIn = true;
    waitingForFirstChord = false;
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = (60 / bpm) * 1000;
    
    let countBeat = 1;
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    
    showCountIn(countBeat);
    countBeat++;
    
    const countInterval = setInterval(() => {
        if (countBeat <= beatsPerBar) {
            showCountIn(countBeat);
            countBeat++;
        } else {
            clearInterval(countInterval);
            hideCountIn();
            isCountingIn = false;
            waitingForFirstChord = true;
            
            startMetronomeWaiting();
            
            if (songMode) {
                checkAndShowCue();
            }
        }
    }, beatDuration);
}

// Start metronome in waiting mode
function startMetronomeWaiting() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now();
    
    isScheduling = true;
    scheduleMetronome();
}

// Start metronome and playback
function startMetronome() {
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    
    currentBeatIndex = 0;
    nextBeatTime = Tone.now();
    
    isScheduling = true;
    scheduleMetronome();
}

// Precise scheduling function using Tone.js timing
function scheduleMetronome() {
    if (!isScheduling) return;
    
    const bpm = parseInt(document.getElementById('bpm').value);
    const timeSignature = document.getElementById('timeSignature').value;
    const division = parseInt(document.querySelector('input[name="division"]:checked').value);
    const beatsPerBar = parseInt(timeSignature.split('/')[0]);
    const beatDuration = 60 / bpm;
    const noteDuration = (beatsPerBar / division) * beatDuration;
    const quarterNoteDuration = 60 / bpm;
    const repeatMode = document.getElementById('repeatMode').checked;
    
    const now = Tone.now();
    const lookAhead = 0.1;
    
    while (nextBeatTime < now + lookAhead) {
        const beatIndex = currentBeatIndex;
        const beatTime = nextBeatTime;
        
        const visualOffset = 0.05;
        Tone.Draw.schedule(() => {
            updateMetronome(beatIndex);
            
            const currentQuarterBeat = Math.floor((beatIndex * noteDuration) / quarterNoteDuration);
            const prevQuarterBeat = beatIndex === 0 ? -1 : Math.floor(((beatIndex - 1) * noteDuration) / quarterNoteDuration);
            
            if (cueCountdown > 0 && currentQuarterBeat !== prevQuarterBeat) {
                updateCueCountdown();
            }
        }, beatTime - visualOffset);
        
        const checkboxes = document.querySelectorAll('.checkboxes-grid input[type="checkbox"]');
        const shouldPlay = currentChord && checkboxes[beatIndex] && checkboxes[beatIndex].checked;
        
        if (shouldPlay && (repeatMode || beatsPlayedInBar < division)) {
            const notes = chordDefinitions[currentChord];
            const playDuration = noteDuration * 0.9;
            synth.triggerAttackRelease(notes, playDuration, beatTime);
        }
        
        nextBeatTime += noteDuration;
        currentBeatIndex++;
        beatsPlayedInBar++;
        
        if (currentBeatIndex >= division) {
            currentBeatIndex = 0;
            
            if (!repeatMode && !songMode && beatsPlayedInBar >= division) {
                Tone.Draw.schedule(() => {
                    currentChord = null;
                    updateChordDisplay(null);
                }, beatTime);
            }
            
            if (nextChord) {
                currentChord = nextChord;
                nextChord = null;
                beatsPlayedInBar = 0;
                Tone.Draw.schedule(() => {
                    updateChordDisplay(currentChord);
                }, beatTime);
            }
        }
    }
    
    requestAnimationFrame(scheduleMetronome);
}

// Stop metronome
function stopMetronome() {
    isScheduling = false;
    
    if (metronomeInterval) {
        clearInterval(metronomeInterval);
        metronomeInterval = null;
    }
    updateMetronome(-1);
    hideCountIn();
    hideSongCue();
    isPlaying = false;
    isCountingIn = false;
    waitingForFirstChord = false;
    currentChord = null;
    nextChord = null;
    updateChordDisplay(null);
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('startBtn').disabled = false;
    
    if (songMode && currentSong) {
        progressionIndex = 0;
        displayProgression();
    }
}

// Handle chord click
async function handleChordClick(chordName) {
    await Tone.start();
    
    const sustainMode = document.getElementById('sustainMode').checked;
    
    if (sustainMode) {
        startSustain(chordName);
        updateChordDisplay(chordName);
        return;
    }
    
    if (songMode) {
        const isCorrect = checkSongChord(chordName);
        
        if (!isCorrect && currentSong) {
            const button = document.querySelector(`[data-chord="${chordName}"]`);
            button.classList.add('wrong-chord-flash');
            setTimeout(() => button.classList.remove('wrong-chord-flash'), 500);
        }
    }
    
    const immediateMode = document.getElementById('immediateMode').checked;
    
    if (immediateMode && isPlaying) {
        isScheduling = false;
        
        currentChord = chordName;
        updateChordDisplay(chordName);
        
        const bpm = parseInt(document.getElementById('bpm').value);
        const timeSignature = document.getElementById('timeSignature').value;
        const division = parseInt(document.querySelector('input[name="division"]:checked').value);
        const beatsPerBar = parseInt(timeSignature.split('/')[0]);
        const beatDuration = 60 / bpm;
        const playDuration = (beatsPerBar / division) * beatDuration * 0.9;
        
        const notes = chordDefinitions[chordName];
        synth.triggerAttackRelease(notes, playDuration, Tone.now());
        
        const button = document.querySelector(`[data-chord="${chordName}"]`);
        button.classList.add('playing');
        setTimeout(() => button.classList.remove('playing'), 200);
        
        currentBeatIndex = 0;
        nextBeatTime = Tone.now();
        nextChord = null;
        beatsPlayedInBar = 0;
        
        isScheduling = true;
        scheduleMetronome();
        
        return;
    }
    
    if (waitingForFirstChord) {
        waitingForFirstChord = false;
        if (!immediateMode) {
            nextChord = chordName;
        } else {
            currentChord = chordName;
            updateChordDisplay(chordName);
        }
        beatsPlayedInBar = 0;
        isPlaying = true;
    } else if (!isPlaying && !isCountingIn) {
        currentChord = chordName;
        updateChordDisplay(chordName);
        beatsPlayedInBar = 0;
        isPlaying = true;
        startMetronome();
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('startBtn').disabled = true;
    } else if (isPlaying && !immediateMode) {
        nextChord = chordName;
    }
}

// Event listeners
document.getElementById('songSelect').addEventListener('change', (e) => {
    loadSong(e.target.value);
});

document.getElementById('instrument').addEventListener('change', (e) => {
    initSynth(e.target.value);
});

document.querySelectorAll('input[name="division"]').forEach(radio => {
    radio.addEventListener('change', () => {
        updateCheckboxes();
        if (isPlaying) {
            startMetronome();
        }
    });
});

document.getElementById('bpm').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.getElementById('timeSignature').addEventListener('change', () => {
    if (isPlaying) {
        startMetronome();
    }
});

document.querySelectorAll('.chord-btn').forEach(btn => {
    btn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('mouseleave', (e) => {
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleChordClick(btn.dataset.chord);
    });
    
    btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
    
    btn.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        stopSustain(btn.dataset.chord);
    });
});

document.getElementById('startBtn').addEventListener('click', async () => {
    await Tone.start();
    startCountIn();
});

document.getElementById('stopBtn').addEventListener('click', stopMetronome);

// Initialize
initSynth('guitar');
updateCheckboxes();
displayChordButtons(['E', 'B', 'G#m', 'C#m', 'A', 'F#m']); // Add this line
    </script>
</body>
</html>